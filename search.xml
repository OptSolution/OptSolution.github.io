<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[statismo代码分析--statismo-build-shape-model]]></title>
    <url>%2F2018%2F11%2F30%2Fstatismo-build-shape-model%2F</url>
    <content type="text"><![CDATA[statismo中statismo-build-shape-model程序代码的解读 总结一下就是：给出参考帧（因为PCA需要先中心化）之后PCA 流程图 命令行参数 -l, --data-list DATA_LIST ：指定一个文件路径，这个文件包含所有用来生成模型的mesh文件路径,每一行只写一个文件 -o, --output-file OUTPUT_FILE ：输出模型文件的路径 -p, --procrustes PROCRUSTES_MODE ：选择数据对齐（aligned）模式。如果选择reference，所有的数据和指定的参考mesh对齐；如果选择GPA，则和均值对齐 -r, --reference FILE ：在PROCRUSTES_MODE选择reference之后，指定参考mesh -n, --noise NOISE ：指定PPCA(probabilistic principal component analysis)模型的噪声方差，默认为0 读入mesh文件的代码 1234567891011121314151617typedef itk::MeshFileReader&lt;MeshType&gt; MeshReaderType;typedef vector&lt;MeshReaderType::Pointer&gt; MeshReaderList;MeshReaderList meshes;meshes.reserve(fileNames.size());for (StringList::const_iterator it = fileNames.begin(); it != fileNames.end(); ++it) &#123; MeshReaderType::Pointer reader = MeshReaderType::New(); reader-&gt;SetFileName(it-&gt;c_str()); reader-&gt;Update(); //这段注释是说Update()这个函数很重要 // itk::PCAModelBuilder is not a Filter in the ITK world, so the pipeline // would not get executed if its main method is called. So the pipeline // before calling itk::PCAModelBuilder must be executed by the means of calls // to Update() (at least for last elements needed by itk::PCAModelBuilder). meshes.push_back(reader);&#125; 关于为什么要用Update()的解释: You only have to call Update() on the last filter in your pipeline. The rest of this answer is the explanation. ITK uses a pipeline execution framework for filters. Assume we have three filters that are connected sequentially like the following: input --&gt; |filter1| --&gt; |filter2| --&gt; |filter3| --&gt; output If you call Update() on filter3, ITK starts from filter3 and checks if the input(s) to each filter have changed. If they have, ITK calls update on them in turn. See slide 5 of this link. 计算平均mesh作为参考mesh的代码 originalMeshes传入的是meshes的指针，也就是align也会影响meshes 12345678910111213141516171819202122232425262728293031typedef itk::Mesh&lt;float, Dimensions&gt; MeshType;///////////////////////////////////////////////////////////////// 将已经读入的mesh都拷贝过来，mesh为之前读入的文件vector&lt;MeshType::Pointer&gt; originalMeshes;for (MeshReaderList::iterator it = meshes.begin(); it != meshes.end(); ++it) &#123; MeshReaderType::Pointer reader = *it; originalMeshes.push_back(reader-&gt;GetOutput());&#125;const unsigned uMaxGPAIterations = 20;const unsigned uNumberOfPoints = 100; // 最多使用这么多个点const float fBreakIfChangeBelow = 0.001f;typedef itk::VersorRigid3DTransform&lt;float&gt; Rigid3DTransformType;typedef itk::Image&lt;float, Dimensions&gt; ImageType;typedef itk::LandmarkBasedTransformInitializer&lt;Rigid3DTransformType, ImageType, ImageType&gt; LandmarkBasedTransformInitializerType;typedef itk::TransformMeshFilter&lt;MeshType, MeshType, Rigid3DTransformType&gt; FilterType;// 计算参考meshMeshType::Pointer referenceMesh = calculateProcrustesMeanMesh&lt;MeshType, LandmarkBasedTransformInitializerType, Rigid3DTransformType, FilterType&gt;( originalMeshes, uMaxGPAIterations, uNumberOfPoints, fBreakIfChangeBelow);representer-&gt;SetReference(referenceMesh); 计算参考mesh的函数 计算流程： 随机取出一些点，只使用这些点进行align 以其中一帧mesh作为初始参考对所有帧进行align 对align后的所有mesh算一个平均mesh 计算当前参考mesh和当前平均mesh的差值 如果差值比较大并且没有达到最大迭代次数就用当前平均mesh覆盖当前参考mesh然后跳转回2，否则返回当前平均mesh 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455template &lt;class MeshType, class LandmarkBasedTransformInitializerType, class TransformType, class FilterType&gt;typename MeshType::PointercalculateProcrustesMeanMesh(std::vector&lt;typename MeshType::Pointer&gt; meshes, unsigned maxIterations, unsigned nrOfLandmarks, float breakIfChangeBelow) &#123; // the initial mesh to which all others will be aligned to is the first one in // the list here. Any other mesh could be chosen as well // 设定第一帧mesh为初始参考mesh typename MeshType::Pointer referenceMesh = *meshes.begin(); unsigned rngSeed = time(0); unsigned meshVerticesCount = referenceMesh-&gt;GetNumberOfPoints(); srand(rngSeed); // 随机数生成器，跟rand()有关 std::set&lt;unsigned&gt; pointNumbers; // 使用点的数量不能超过nrOfLandmarks // 使用点的索引是随机获取的 while (pointNumbers.size() &lt; std::min(nrOfLandmarks, meshVerticesCount)) &#123; // 随机获得一个点的索引，但是没有多余的处理是否会添加重复的点？ unsigned randomIndex = ((unsigned)rand()) % meshVerticesCount; pointNumbers.insert(randomIndex); &#125; float fPreviousDifference = -1; // 进入迭代 for (unsigned i = 0; i &lt; maxIterations; ++i) &#123; // calculate the difference to the previous iteration's mesh and break if // the difference is very small // 计算每一个mesh和当前参考mesh之间的刚体变换，并且进行align std::vector&lt;typename MeshType::Pointer&gt; translatedMeshes = superimposeMeshes&lt;MeshType, LandmarkBasedTransformInitializerType, TransformType, FilterType&gt;(meshes, referenceMesh, pointNumbers); // 计算align后的平均mesh typename MeshType::Pointer meanMesh = calculateMeanMesh&lt;MeshType&gt;(translatedMeshes); // 计算当前平均mesh和当前参考mesh的差值 float fDifference = calculateMeshDistance&lt;MeshType&gt;(meanMesh, referenceMesh); float fDifferenceDelta = std::abs(fDifference - fPreviousDifference); fPreviousDifference = fDifference; referenceMesh = meanMesh; // 如果小于阈值认为收敛了 if (fDifferenceDelta &lt; breakIfChangeBelow) &#123; break; &#125; &#125; return referenceMesh;&#125; Align的函数 使用随机采样的对应点计算每一帧mesh和当前参考mesh之间的刚体变换，并且进行align 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566template &lt;class MeshType, class LandmarkBasedTransformInitializerType, class TransformType, class FilterType&gt;std::vector&lt;typename MeshType::Pointer&gt;superimposeMeshes(std::vector&lt;typename MeshType::Pointer&gt; originalMeshes, typename MeshType::Pointer referenceMesh, std::set&lt;unsigned&gt; landmarkIndices) &#123; std::vector&lt;typename MeshType::Pointer&gt; translatedMeshes( originalMeshes.begin(), originalMeshes.end()); //遍历每一帧mesh，计算每一mesh相对于当前参考mesh的刚体变换并align for (typename std::vector&lt;typename MeshType::Pointer&gt;::iterator it = translatedMeshes.begin(); it != translatedMeshes.end(); ++it) &#123; typedef typename LandmarkBasedTransformInitializerType::LandmarkPointContainer LandmarkContainerType; LandmarkContainerType movingLandmarks; LandmarkContainerType fixedLandmarks; typename MeshType::Pointer movingMesh = *it; // 数据点数和拓扑都需要一致（实际上索引相同的点需要已经对应好） if (movingMesh-&gt;GetNumberOfPoints() != referenceMesh-&gt;GetNumberOfPoints() || movingMesh-&gt;GetNumberOfCells() != referenceMesh-&gt;GetNumberOfCells()) &#123; itkGenericExceptionMacro( &lt;&lt; "All meshes must have the same number of Edges &amp; Vertices"); &#125; // Only use a subset of the meshes' points for the alignment since we don't // have that many degrees of freedom anyways and since calculating a SVD with // too many points is expensive // 使用前面随机选出来的部分点进行计算 for (std::set&lt;unsigned&gt;::const_iterator rng = landmarkIndices.begin(); rng != landmarkIndices.end(); ++rng) &#123; movingLandmarks.push_back(movingMesh-&gt;GetPoint(*rng)); fixedLandmarks.push_back(referenceMesh-&gt;GetPoint(*rng)); &#125; // only rotate &amp; translate the moving mesh to best fit with the fixed mesh; // there's no scaling taking place. // 使用这一部分点计算mesh和当前参考mesh之间的刚体变换 typename LandmarkBasedTransformInitializerType::Pointer landmarkBasedTransformInitializer = LandmarkBasedTransformInitializerType::New(); landmarkBasedTransformInitializer-&gt;SetFixedLandmarks(fixedLandmarks); landmarkBasedTransformInitializer-&gt;SetMovingLandmarks(movingLandmarks); typename TransformType::Pointer transform = TransformType::New(); transform-&gt;SetIdentity(); landmarkBasedTransformInitializer-&gt;SetTransform(transform); landmarkBasedTransformInitializer-&gt;InitializeTransform(); // 使用计算得到的刚体变换进行align，这里是mesh上所有的点 typename FilterType::Pointer filter = FilterType::New(); filter-&gt;SetInput(movingMesh); filter-&gt;SetTransform(transform); filter-&gt;Update(); *it = filter-&gt;GetOutput(); &#125; return translatedMeshes;&#125; 计算平均mesh的函数 遍历求和，然后遍历求平均 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788template &lt;class MeshType&gt;typename MeshType::PointercalculateMeanMesh(std::vector&lt;typename MeshType::Pointer&gt; meshes) &#123; // 必须要存在mesh if (meshes.size() == 0) &#123; itkGenericExceptionMacro( &lt;&lt; "Can't calculate the mean since no meshes were provided."); &#125; // 使用这个类型的原因是这个类型精度更高 typedef itk::CompensatedSummation&lt;typename MeshType::PixelType&gt; CompensatedSummationType; typedef std::vector&lt;CompensatedSummationType&gt; MeshPointsVectorType; typename MeshType::Pointer pFirstMesh = *meshes.begin(); // prepare for summation MeshPointsVectorType vMeshPoints; // shape向量的长度，点数乘上每个点的维度 unsigned uDataSize = pFirstMesh-&gt;GetNumberOfPoints() * MeshType::PointDimension; vMeshPoints.reserve(uDataSize); for (int i = 0; i &lt; uDataSize; ++i) &#123; CompensatedSummationType sum; vMeshPoints.push_back(sum); &#125; // 遍历每个mesh // 求和 for (typename std::vector&lt;typename MeshType::Pointer&gt;::const_iterator i = meshes.begin(); i != meshes.end(); ++i) &#123; typename MeshType::Pointer pMesh = *i; // 验证向量维度(点的个数和点的维度)要一样 if (vMeshPoints.size() != pMesh-&gt;GetNumberOfPoints() * MeshType::PointDimension) &#123; itkGenericExceptionMacro( &lt;&lt; "All meshes must have the same number of Edges"); &#125; typename MeshPointsVectorType::iterator sum = vMeshPoints.begin(); typename MeshType::PointsContainer::ConstIterator pointData = pMesh-&gt;GetPoints()-&gt;Begin(); // sum up all meshes // 遍历这个mesh的每个点 for (; pointData != pMesh-&gt;GetPoints()-&gt;End(); ++pointData) &#123; const typename MeshType::PointType point = pointData-&gt;Value(); // 遍历这个点的每个维度 // 将对应维度的数值加入vMeshPoints中 for (typename MeshType::PointType::ConstIterator pointIter = point.Begin(); pointIter != point.End(); ++pointIter, ++sum) &#123; (*sum) += *pointIter; &#125; &#125; &#125; float fInvNumberOfMeshes = 1.0f / meshes.size(); // 虽然是复制的第一帧mesh，但是后面是直接覆盖 typename MeshType::Pointer pMeanMesh = cloneMesh&lt;MeshType&gt;(pFirstMesh); // write the data to the mean mesh typename MeshPointsVectorType::iterator sum = vMeshPoints.begin(); // 遍历meanmesh的每个点 // 计算平均值 for (typename MeshType::PointsContainer::Iterator pointData = pMeanMesh-&gt;GetPoints()-&gt;Begin(); pointData != pMeanMesh-&gt;GetPoints()-&gt;End(); ++pointData) &#123; // 遍历点的每个维度 for (typename MeshType::PointType::Iterator pointIter = pointData-&gt;Value().Begin(); pointIter != pointData-&gt;Value().End(); ++pointIter, ++sum) &#123; // 计算平均值传给meanmesh *pointIter = sum-&gt;GetSum() * fInvNumberOfMeshes; &#125; &#125; return pMeanMesh;&#125; 计算平均mesh和当前参考mesh的差值 每对对应点的距离求和，再除以shape向量的整体维度进行平均 12345678910111213141516171819202122232425template &lt;class MeshType&gt;float calculateMeshDistance(typename MeshType::Pointer mesh1, typename MeshType::Pointer mesh2) &#123; // 点数和拓扑要一样（实际上也需要完全对应） if (mesh1-&gt;GetNumberOfPoints() != mesh2-&gt;GetNumberOfPoints() || mesh1-&gt;GetNumberOfCells() != mesh2-&gt;GetNumberOfCells()) &#123; itkGenericExceptionMacro( &lt;&lt; "Both meshes must have the same number of Edges &amp; Vertices"); &#125; float fDifference = 0; typedef typename MeshType::PointsContainer::Iterator IteratorType; IteratorType point1 = mesh1-&gt;GetPoints()-&gt;Begin(); IteratorType point2 = mesh2-&gt;GetPoints()-&gt;Begin(); // 每对对应点的距离求和 for (; point1 != mesh1-&gt;GetPoints()-&gt;End(); ++point1, ++point2) &#123; fDifference += point1-&gt;Value().SquaredEuclideanDistanceTo(point2-&gt;Value()); &#125; // 除以（mesh点的个数 乘上 点的维度） fDifference /= (mesh1-&gt;GetNumberOfPoints() * MeshType::PointDimension); return fDifference;&#125; 将参考帧加入数据管理 1234567891011typedef itk::Mesh&lt;float, Dimensions&gt; MeshType;typedef itk::DataManager&lt;MeshType&gt; DataManagerType;DataManagerType::Pointer dataManager = DataManagerType::New();////////////////////////////////////////////////////////////////////dataManager-&gt;SetRepresenter(representer);for (MeshReaderList::const_iterator it = meshes.begin(); it != meshes.end(); ++it) &#123; MeshReaderType::Pointer reader = *it; dataManager-&gt;AddDataset(reader-&gt;GetOutput(), reader-&gt;GetFileName());&#125; 进行PCA并保存model 这个PCA之前没有align的过程？？GPA会进行align，但是如果选择reference这里就没有进行align了？ 123456789101112// model类型typedef itk::StatisticalModel&lt;MeshType&gt; StatisticalModelType;StatisticalModelType::Pointer model;// 利用itk接口进行PCAtypedef itk::PCAModelBuilder&lt;MeshType&gt; PCAModelBuilder;PCAModelBuilder::Pointer pcaModelBuilder = PCAModelBuilder::New();// 直接就进行PCA了model = pcaModelBuilder-&gt;BuildNewModel(dataManager-&gt;GetData(), opt.fNoiseVariance);// 保存为文件itk::StatismoIO&lt;MeshType&gt;::SaveStatisticalModel( model, opt.strOutputFileName.c_str()); st=>start: 开始 ed=>end: 退出 io1=>inputoutput: 输入命令行参数 op1=>operation: 读取命令行参数 cond1=>condition: 参数是否 符合要求？ io2=>inputoutput: 无法执行 op2=>operation: 读入mesh文件 cond2=>condition: 输入参数是否设 置了参考mesh？ op3=>operation: 按照设置选择已有 mesh为参考mesh op4=>operation: 计算参考mesh (有相关代码详解) op5=>operation: 设定参考mesh并将每 帧mesh加入数据管理 op6=>operation: 利用itk接口进行PCA io3=>inputoutput: 保存model文件 st->io1->op1->cond1 cond1(no)->io2->ed cond1(yes)->op2->cond2 cond2(yes, right)->op3->op5 cond2(no)->op4->op5 op5->op6->io3->ed{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);]]></content>
      <tags>
        <tag>statismo</tag>
        <tag>code</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bundle Adjustment简述]]></title>
    <url>%2F2018%2F11%2F29%2FBA%2F</url>
    <content type="text"><![CDATA[笔者到底想讲些啥？ 在SFM（structure from motion）的计算中BA（Bundle Adjustment）作为最后一步优化具有很重要的作用，在近几年兴起的基于图的SLAM（simultaneous localization and mapping）算法里面使用了图优化替代了原来的滤波器，这里所谓的图优化其实也是指BA。其实很多经典的文献对于BA都有深深浅浅的介绍，如果想对BA的全过程做一个全面的更深层次的了解，推荐阅读 Bundle Adjustment —A Modern Synthesis，但是BA的内容确实太多太杂了，刚对其了解的时候往往会陷入其局部的计算中不能自拔，因此笔者准备对其进行一个比较全局一点的介绍，希望读者可以比较轻松的一览BA的全过程而不是陷入其局部的繁琐的计算中，同时也会尽量对其需要的数学工具介绍全面，如有错误和遗漏还望指正。 如果读者对以下内容有基本了解那可就太棒棒了！ 射影相机几何模型 对极几何 凸优化 矩阵理论 这才是真的开始 Bundle Adjustment（之后在不引起歧义的情况下用BA代替，你问为什么？笔者懒啊-。-），大概似乎也许好像有近百年的历史了吧（没错，可以称为state-of-art的视觉SLAM在几年前才用上将近上百岁的算法），中文译为光束法平差，大概大家看到更多的翻译可能为束调整、捆集调整或者捆绑调整等等。这么多翻译笔者最喜欢的还是光束法平差，一看就比其它的更专业逼格更高嘛，其它的翻译都太直译了。当然最重要的是光束法平差完美的表达了BA的来源、原理和计算过程，而其他的只是强调了将很多数据放在一起进行优化计算这个事。不信？那我们来分析一下嘛。 所谓bundle，来源于bundle of light，其本意就是指的光束，这些光束指的是三维空间中的点投影到像平面上的光束，而重投影误差（后面会讲这到底是个什么鬼）正是利用这些光束来构建的，因此称为光束法强调光束也正是描述其优化模型是如何建立的。剩下的就是平差，那什么是平差呢？借用一下百度词条 测量平差 中的解释吧。 由于测量仪器的精度不完善和人为因素及外界条件的影响，测量误差总是不可避免的。为了提高成果的质量，处理好这些测量中存在的误差问题，观测值的个数往往要多于确定未知量所必须观测的个数，也就是要进行多余观测。有了多余观测，势必在观测结果之间产生矛盾，测量平差的目的就在于消除这些矛盾而求得观测量的最可靠结果并评定测量成果的精度。测量平差采用的原理就是“最小二乘法”。 平差也就正好表述了为什么需要BA以及BA这个优化过程到底是怎么进行的。 BA模型到底是怎么来的？ 感觉前面废话说了一大堆，解释了半天BA的中文翻译，那么BA到底是干嘛的呢？经过前面的铺垫，用一句话来描述BA那就是，BA的本质是一个优化模型，其目的是最小化重投影误差 本质是一个优化模型应该很容易理解，那么什么是重投影误差呢？投影自然是个几何的问题，既然是几何问题那这个时候来个图自然就是最棒棒了！ 看！这些五颜六色的线就是我们讲的光束啦！那现在就该说下什么叫重投影误差了，重投影也就是指的第二次投影，那到底是怎么投影的呢？我们来整理一下吧： 其实第一次投影指的就是相机在拍照的时候三维空间点投影到图像上 然后我们利用这些图像对一些特征点进行三角定位（triangulation，很多地方翻译为三角化或者三角剖分等等，当然笔者最喜欢的还是三角定位，显然是利用几何信息构建三角形来确定三维空间点的位置嘛，相关内容请参考对极几何） 最后利用我们计算得到的三维点的坐标（注意不是真实的）和我们计算得到的相机矩阵（当然也不是真实的）进行第二次投影，也就是重投影 现在我们知道什么是重投影了，那重投影误差到底是什么样的误差呢？这个误差是指的真实三维空间点在图像平面上的投影（也就是图像上的像素点）和重投影（其实是用我们的计算值得到的虚拟的像素点）的差值，因为种种原因计算得到的值和实际情况不会完全相符，也就是这个差值不可能恰好为0，此时也就需要将这些差值的和最小化获取最优的相机参数及三维空间点的坐标。 进入数学模式！ 感觉像写小说一样写了一堆堆的文字，既然BA是个数学问题，不用数学讲讲好像不太行，接下来就看看BA的数学模型是怎么构建的吧。 对BA有点了解的同学可能知道BA是一个图优化模型，那首先肯定要构造一个图模型了（没学过图论也没事，后面还是会回到一般的优化模型）。既然是图模型那自然就有节点和边了，这个图模型的节点由相机PiP_iPi​和三维空间点构成XjX_jXj​构成，如果点XjX_jXj​投影到相机PiP_iPi​的图像上则将这两个节点连接起来。还是来张图吧。 这样就一目了然了。那么我们现在就可以通过这个图来构造优化模型了。 令点XjX_jXj​在相机PiP_iPi​拍摄到的图像归一化坐标系上的坐标为k(uijT,1)T=Ki−1xijk(u_{ij}^T,1)^T=K_i^{-1}x_{ij}k(uijT​,1)T=Ki−1​xij​，其重投影后的图像归一化坐标系下坐标为k′(vijT,1)T=Ki−1PiXjk&#x27;(v_{ij}^T,1)^T=K_i^{-1}P_iX_jk′(vijT​,1)T=Ki−1​Pi​Xj​，其中Ki−1K_i^{-1}Ki−1​是为了在计算时能不受相机内参影响kkk和k′k&#x27;k′是将齐次坐标转换为非齐次坐标的常数项，可以得到该重投影误差为 eij=∥uij−vij∥e_{ij}=\|u_{ij}-v_{ij}\| eij​=∥uij​−vij​∥ BA是要将所有重投影误差的和最小化，那么这里自然就要开始求和了。 min⁡Ri,ti,Xj∑i,jσij∥uij−vij∥\min_{R_i,t_i,X_j} \sum_{i,j} \sigma_{ij}\|u_{ij}-v_{ij}\| Ri​,ti​,Xj​min​i,j∑​σij​∥uij​−vij​∥ 其中当点XjX_jXj​在相机PiP_iPi​中有投影时σij=1\sigma_{ij}=1σij​=1，否则为σij=0\sigma_{ij}=0σij​=0。 到此我们就得到了BA优化模型的数学形式了。 接下来就应该开始计算了！ 既然是优化模型，那自然就应该用各种优化算法来进行计算了。这里先小小的剧透一下，BA现在基本都是利用LM（Levenberg-Marquardt）算法并在此基础上利用BA模型的稀疏性质来进行计算的，LM算法是最速下降法（梯度下降法）和Gauss-Newton的结合体，至于是怎么结合的接下来就来慢慢介绍了。 最速下降法 如果你对梯度比较熟悉的话，那你应该知道梯度方向是函数上升最快的方向，而此时我们需要解决的问题是让函数最小化。你应该想到了，那就顺着梯度的负方向去迭代寻找使函数最小的变量值就好了嘛。梯度下降法就是用的这种思想，用数学表达的话大概就是这样 xk=xk−1−λ∇f(xk−1)x_k = x_{k-1}-\lambda \nabla f(x_{k-1}) xk​=xk−1​−λ∇f(xk−1​) 其中λ\lambdaλ为步长。 最速下降法保证了每次迭代函数都是下降的，在初始点离最优点很远的时候刚开始下降的速度非常快，但是最速下降法的迭代方向是折线形的导致了收敛非常非常的慢。 Newton型方法 现在先回顾一下中学数学，给定一个开口向上的一元二次函数，如何知道该函数何处最小？这个应该很容易就可以答上来了，对该函数求导，导数为000处就是函数最小处。 Newton型方法也就是这种思想，首先将函数利用泰勒展开到二次项： f(x+δx)≈φ(δx)=f(x)+J(x)δx+12δxTH(x)δx\mathbf{f(x + \delta x) \approx \varphi(\delta x) = f(x) + J(x)\delta x + \frac{1}{2}\delta x^T H(x) \delta x} f(x+δx)≈φ(δx)=f(x)+J(x)δx+21​δxTH(x)δx 其中J\mathbf{J}J为Jacobi矩阵，对矩阵函数求一次偏导而来，梯度也是对向量函数求一次偏导而来。将标量考虑为1×11 \times 11×1的矩阵，将向量考虑为n×1n \times 1n×1的矩阵，其实这些求导都是求Jacobi矩阵。H\mathbf{H}H为Hessian矩阵，也就是二次偏导矩阵。 也就是说Newton型方法将函数局部近似成一个二次函数进行迭代，然后令x\mathbf{x}x在δx\mathbf{\delta x}δx方向上迭代直至收敛，接下来自然就对这个函数求导了： φ′(δx)=J+Hδx=0\mathbf{\varphi&#x27;(\delta x) = J + H \delta x = 0 } φ′(δx)=J+Hδx=0 ⟹δx=−H−1J\Longrightarrow \mathbf{ \delta x = -H^{-1}J } ⟹δx=−H−1J Newton型方法收敛的时候特别快，尤其是对于二次函数而言一步就可以得到结果。但是该方法有个最大的缺点就是Hessian矩阵计算实在是太复杂了，并且Newton型方法的迭代并不像最速下降法一样保证每次迭代都是下降的。 Gauss-Newton方法 既然Newton型方法计算Hessian矩阵太困难了，那有没有什么方法可以不计算Hessian矩阵呢？将泰勒展开式的二次项也去掉好像就可以避免求Hessian矩阵了吧，就像这样： f(x+δx)≈f(x)+J(x)δx\mathbf{f(x + \delta x) \approx f(x) + J(x)\delta x} f(x+δx)≈f(x)+J(x)δx 这好像变成了一个线性函数了啊，线性函数如果要最小化的话好像是需要增加其他的约束条件的啊。那这里有没有其他的约束条件呢？仔细思考一下，我们需要最小化的是重投影误差eij=∥uij−vij∥e_{ij}=\|u_{ij}-v_{ij}\|eij​=∥uij​−vij​∥，它的最小值是什么呢？理想状态下当然是等于000了。所以这个时候就不应该求导了，而是直接令函数为000。此时，令f(x)=ε\mathbf{f(x) = \varepsilon}f(x)=ε有 ε+Jδx=0\mathbf{\varepsilon + J \delta x = 0} ε+Jδx=0 ⟹JTJδx=−JTε\Longrightarrow \mathbf{J^{T} J \delta x = - J^{T} \varepsilon} ⟹JTJδx=−JTε x=x+δx\mathbf{x = x + \delta x} x=x+δx 由此x\mathbf{x}x在δx\mathbf{\delta x}δx方向上迭代直至∥ε∥\| \varepsilon \|∥ε∥最小。 Gauss-Newton方法就避免了求Hessian矩阵，并且在收敛的时候依旧很快。但是依旧无法保证每次迭代的时候函数都是下降的。 LM方法 LM方法就是在以上方法基础上的改进，通过参数的调整使得优化能在最速下降法和Gauss-Newton法之间自由的切换，在保证下降的同时也能保证快速收敛。 Gauss-Newton最后需要求解的方程为 JTJδx=−JTε\mathbf{J^{T} J \delta x = - J^{T} \varepsilon} JTJδx=−JTε LM算法在此基础上做了更改，变成了 (JTJ+λI)δx=−JTε\mathbf{(J^{T} J + \lambda I) \delta x = - J^{T} \varepsilon} (JTJ+λI)δx=−JTε 通过参数λ\lambdaλ的调节在最速下降法和Gauss-Newton法之间切换。做个不很数学的直观分析吧，当λ\lambdaλ很小时，显然和Gauss-Newton法是一样的；当λ\lambdaλ很大时，就变成了这样： λIδx=−JTϵ\mathbf{\lambda I \delta x = - J^T \epsilon} λIδx=−JTϵ ⟹δx=−λ−1JTϵ\Longrightarrow \mathbf{\delta x = - \lambda^{-1}J^T \epsilon} ⟹δx=−λ−1JTϵ 然后再看看前面的最速下降法？ 这里还存在一个问题，当λ\lambdaλ取某个值的时候可能会导致JJ+λI\mathbf{J^J + \lambda I}JJ+λI不可逆，所以这里变成了 (JTJ+λdiag(JTJ))δx=−JTε\mathbf{(J^{T} J + \lambda diag(J^T J)) \delta x = - J^{T} \varepsilon} (JTJ+λdiag(JTJ))δx=−JTε 其实LM算法的具体形式就笔者看到的就有很多种，但是本质都是通过参数λ\lambdaλ在最速下降法和Gauss-Newton法之间切换。这里选用的是维基百科上的形式。 LM算法就由此保证了每次迭代都是下降的，并且可以快速收敛。 还没完呢！别忘了还要解方程 LM算法主体就是一个方程的求解，也是其计算量最大的部分。当其近似于最速下降法的时候没有什么好讨论的，但是当其近似于Gauss-Newton法的时候，这个最小二乘解的问题就该好好讨论一下了。以下的讨论就利用Gauss-Newton的形式来求解。 稠密矩阵的最小二乘解 对于形如Ax=bAx=bAx=b的超定参数方程而言，有很多求解方式，伪逆、QR分解、SVD等等，这里不展开谈，想具体了解的可以去查阅矩阵理论相关资料。这些方式都有一个共同的特点，我们都是将AAA看作一般的稠密矩阵，主要得到的解自然非常鲁棒，都是计算量却是和维数的三次方成正比（O(n3)O(n^3)O(n3)）。面对BA这种超大规模的优化似乎有点不太实用。 稀疏矩阵的Cholesky分解 稠密矩阵计算起来那么复杂，如果是稀疏矩阵的话利用其稀疏的性质可以大幅减少计算量，对于稀疏矩阵的Cholesky分解就是这样。其分解形式为一个上三角矩阵的转置乘上自身： A≈RTRA \approx R^T R A≈RTR RTRx=bR^TRx = b RTRx=b x=R−1R−Tbx = R^{-1}R^{-T}b x=R−1R−Tb 为什么说我们的矩阵是稀疏的 用一个非常简单的例子来解释吧，考虑有两个相机矩阵P1P_1P1​和P2P_2P2​、两个空间点X1X_1X1​和X2X_2X2​，其中X1X_1X1​只在P2P_2P2​中有投影，X2X_2X2​在两个相机（或视角）中都有投影。令优化函数为f(P1,P2,X1,X2)f(P_1,P_2,X_1,X_2)f(P1​,P2​,X1​,X2​)，此时Jacobi矩阵为 J=[∂f∂P1∂f∂X2∂f∂P2∂f∂X1∂f∂P2∂f∂X2]\mathbf{J} = \left[ \begin{array}{cc|cc} \frac{\partial f}{\partial P_1} &amp; &amp; &amp; \frac{\partial f}{\partial X_2} \\\\ &amp; \frac{\partial f}{\partial P_2} &amp; \frac{\partial f}{\partial X_1} &amp; \\\\ &amp; \frac{\partial f}{\partial P_2} &amp; &amp; \frac{\partial f}{\partial X_2} \end{array} \right] J=⎣⎢⎢⎢⎢⎢⎡​∂P1​∂f​​∂P2​∂f​∂P2​∂f​​∂X1​∂f​​∂X2​∂f​∂X2​∂f​​⎦⎥⎥⎥⎥⎥⎤​ 考虑相机位置（图像数量）和空间点都非常多的情况，不难想象Jacobi矩阵不光是一个稀疏矩阵而且还可以写成形如[A∣B][A|B][A∣B]的分块矩阵。接下来就该利用这些性质正式进入计算了！ 开始计算吧！ 现在再回到Gauss-Newton最后的超定参数方程吧。既然Jacobi矩阵可以分块那我们就先分块，分块可以有效降低需要计算的矩阵的维度并以此减少计算量。 JTJδx=−JTε\mathbf{J^{T} J \delta x = - J^{T} \varepsilon} JTJδx=−JTε J=[A∣B]\mathbf{J}=[A|B] J=[A∣B] [A∣B]T[A∣B]δx=−[A∣B]Tε[A|B]^T[A|B]\mathbf{\delta x}=-[A|B]^T \varepsilon [A∣B]T[A∣B]δx=−[A∣B]Tε [ATAATBBTABTB][δxAδxB]=−[ATεBTε]\begin{bmatrix} A^TA &amp; A^TB \\\\ B^TA &amp; B^TB \end{bmatrix} \begin{bmatrix} \mathbf{\delta x}_A \\\\ \mathbf{\delta x}_B \end{bmatrix} = - \begin{bmatrix} A^T \varepsilon \\\\ B^T \varepsilon \end{bmatrix} ⎣⎡​ATABTA​ATBBTB​⎦⎤​⎣⎡​δxA​δxB​​⎦⎤​=−⎣⎡​ATεBTε​⎦⎤​ [UWWTV][δxAδxB]=[εAεB]\begin{bmatrix} U &amp; W \\\\ W^T &amp; V \end{bmatrix} \begin{bmatrix} \mathbf{\delta x}_A \\\\ \mathbf{\delta x}_B \end{bmatrix} = \begin{bmatrix} \varepsilon _A \\\\ \varepsilon _B \end{bmatrix} ⎣⎡​UWT​WV​⎦⎤​⎣⎡​δxA​δxB​​⎦⎤​=⎣⎡​εA​εB​​⎦⎤​ [I−WV−10I][UWWTV][δxAδxB]=[I−WV−10I][εAεB]\begin{bmatrix} I &amp; -WV^{-1} \\\\ 0 &amp; I \end{bmatrix} \begin{bmatrix} U &amp; W \\\\ W^T &amp; V \end{bmatrix} \begin{bmatrix} \mathbf{\delta x}_A \\\\ \mathbf{\delta x}_B \end{bmatrix} = \begin{bmatrix} I &amp; -WV^{-1} \\\\ 0 &amp; I \end{bmatrix} \begin{bmatrix} \varepsilon _A \\\\ \varepsilon _B \end{bmatrix} ⎣⎡​I0​−WV−1I​⎦⎤​⎣⎡​UWT​WV​⎦⎤​⎣⎡​δxA​δxB​​⎦⎤​=⎣⎡​I0​−WV−1I​⎦⎤​⎣⎡​εA​εB​​⎦⎤​ [U−WV−1WT0WTV][δxAδxB]=[εA−WV−1εBεB]\begin{bmatrix} U-WV^{-1}W^T &amp; 0 \\\\ W^T &amp; V \end{bmatrix} \begin{bmatrix} \mathbf{\delta x}_A \\\\ \mathbf{\delta x}_B \end{bmatrix} = \begin{bmatrix} \varepsilon _ A - WV^{-1}\varepsilon _B \\\\ \varepsilon _B \end{bmatrix} ⎣⎡​U−WV−1WTWT​0V​⎦⎤​⎣⎡​δxA​δxB​​⎦⎤​=⎣⎡​εA​−WV−1εB​εB​​⎦⎤​ {(U−WV−1WT)δA=εA−WV−1εBWTδA+VδB=εB\begin{cases} (U-WV^{-1}W^T) \delta _A = \varepsilon _ A - WV^{-1}\varepsilon _B \\\\ W^T \delta _A + V \delta _B = \varepsilon _B \end{cases} ⎩⎪⎨⎪⎧​(U−WV−1WT)δA​=εA​−WV−1εB​WTδA​+VδB​=εB​​ 由此我们可以先求出δA\delta _AδA​，然后代回求出δB\delta _BδB​。其中U−WV−1WTU-WV^{-1}W^TU−WV−1WT被称为舒尔补（Schur complement）。分块降维之后的计算就可以利用稀疏的Cholesky分解进行计算了。 注意事项！ 以上就基本将BA的整个过程进行了介绍，当然这只是最基础的思路，接下来一些遗漏点进行补充。 李群及李代数 不知道有没有人注意到，在优化迭代的过程中，我们求的值为δx\delta xδx，然后利用x+δxx + \delta xx+δx来更新xxx的值。这里就应该出现一个问题了，对于空间点的坐标和平移向量这么处理自然没有什么问题，但是对于旋转矩阵呢？难道用R+δRR + \delta RR+δR来更新RRR的值吗？好像不太对吧。 对于旋转矩阵RRR而言是不存在加法的，按理讲应该用RδRR \delta RRδR来更新RRR的值，但是优化算法的迭代过程又不能是乘法，这就出现了矛盾。 这里旋转矩阵及相关运算属于李群，此时将旋转矩阵变换到其对应的李代数上进行计算，然后再变回李群。打个不是那么恰当的比方，在计算卷积的时候常常通过傅里叶变换计算乘积然后再反变换回来就是要求的卷积了，这个也是转换到李代数上计算然后再变回李群。具体的推导可以参看李群及李代数相关内容。 协方差矩阵 在我们的推导中是求解方程 JTJδx=−JTε\mathbf{J^{T} J \delta x = - J^{T} \varepsilon} JTJδx=−JTε 但常常加入信息矩阵（协方差矩阵的逆），令求解方程变为 JTΣx−1Jδx=−JTΣx−1ε\mathbf{J^{T} \Sigma_x^{-1} J \delta x = - J^{T} \Sigma_x^{-1} \varepsilon} JTΣx−1​Jδx=−JTΣx−1​ε 其中Σx\mathbf{\Sigma_x}Σx​为协方差矩阵，令其为分块对角阵表示所有观测向量都不相关。 参考文献 Triggs B, McLauchlan P F, Hartley R I, et al. Bundle adjustment—a modern synthesis[C]//International workshop on vision algorithms. Springer Berlin Heidelberg, 1999: 298-372. Hartley R, Zisserman A. Multiple view geometry in computer vision[M]. Cambridge university press, 2003. Barfoot T D. STATE ESTIMATION FOR ROBOTICS[J]. 2017.]]></content>
      <tags>
        <tag>BA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四元数及error-state kalman]]></title>
    <url>%2F2018%2F11%2F28%2FQuaternion-kinematics%2F</url>
    <content type="text"><![CDATA[四元数相关的基本推导，主要是扰动相关。然后记下了一些error-state kalman相关的公式。 不做具体说明时，都是右手系 四元数乘法 q⊗p≠p⊗qq \otimes p \neq p \otimes q q⊗p≠p⊗q 其中⊗\otimes⊗为四元数乘法，ppp和qqq为四元数，四元数乘法满足结合律和分配律。四元数乘法为二元运算，可以写成两种等价的形式： q⊗p=[q]Lp=[p]Rqq \otimes p = {[q]}_L p = {[p]}_Rq q⊗p=[q]L​p=[p]R​q [q]L=qwI+[0−qvTqv[qv]×][q]_L = q_wI + \begin{bmatrix} 0 &amp; -q_v^T \\ q_v &amp; [q_v]_{\times} \end{bmatrix} [q]L​=qw​I+[0qv​​−qvT​[qv​]×​​] [q]R=qwI+[0−qvTqv−[qv]×][q]_R = q_wI + \begin{bmatrix} 0 &amp; -q_v^T \\ q_v &amp; -[q_v]_{\times} \end{bmatrix} [q]R​=qw​I+[0qv​​−qvT​−[qv​]×​​] 其中q=(qw,qv)q = (q_w, q_v)q=(qw​,qv​)，qwq_wqw​为实数，qvq_vqv​为其中虚数向量。 左手系和右手系在四元数计算上的区别： 右手系：ij=−ji=kij = -ji = kij=−ji=k， jk=−kj=ijk = -kj = ijk=−kj=i，ki=−ik=jki = -ik = jki=−ik=j 左手系：ij=−ji=−kij = -ji = -kij=−ji=−k，jk=−kj=−ijk = -kj = -ijk=−kj=−i，ki=−ik=−jki = -ik = -jki=−ik=−j Eigen中的四元数运算如果使用方法 coeffs()输出系数，输出的向量是按照(qv,qw)(q_v,q_w)(qv​,qw​)排列的。在Eigen中四元数的构造函数中，输入参数顺序是按照(qw,qv)(q_w,q_v)(qw​,qv​)排列的。所以想使用四元数乘法的时候可以构造四元数使用Eigen的四元数相乘函数来避免这些问题。但是想使用Eigen的四元数系数进行四元数乘法运算时（尤其对于论文里面经常提到的Ω\OmegaΩ矩阵），其形式为 [q]L=qwI+[[qv]×qv−qvT0][q]_L = q_wI +\begin{bmatrix}[q_v]_{\times} &amp; q_v \\-q_v^T &amp; 0\end{bmatrix}[q]L​=qw​I+[[qv​]×​−qvT​​qv​0​] [q]R=qwI+[−[qv]×qv−qvT0][q]_R = q_wI +\begin{bmatrix}-[q_v]_{\times} &amp; q_v \\-q_v^T &amp; 0\end{bmatrix}[q]R​=qw​I+[−[qv​]×​−qvT​​qv​0​] 当然计算结果自然是按照(qv,qw)(q_v,q_w)(qv​,qw​)排列的四元数 由于 q⊗r⊗p=[p]R[q]Lrq \otimes r \otimes p = [p]_R[q]_Lr q⊗r⊗p=[p]R​[q]L​r q⊗r⊗p=[q]L[p]Rrq \otimes r \otimes p = [q]_L[p]_Rr q⊗r⊗p=[q]L​[p]R​r 因此有[p]R[q]L=[q]L[p]R[p]_R[q]_L = [q]_L[p]_R[p]R​[q]L​=[q]L​[p]R​ 扰动及求导 先交代一些东西 qAB⊗qBC=qACq_{AB} \otimes q_{BC} = q_{AC} qAB​⊗qBC​=qAC​ RABRBC=RACR_{AB} R_{BC} = R_{AC} RAB​RBC​=RAC​ Δq=[112Δθ]+O(∥Δθ∥2)\Delta q = \begin{bmatrix} 1 \\ \frac{1}{2} \Delta \theta \end{bmatrix} + O \left( \| \Delta \theta \|^2 \right) Δq=[121​Δθ​]+O(∥Δθ∥2) ΔR=I+[Δθ]×+O(∥Δθ∥2)\Delta R = I + [\Delta \theta]_{\times} + O\left( \| \Delta \theta \|^2 \right) ΔR=I+[Δθ]×​+O(∥Δθ∥2) 下文可能使用局部到全局坐标系的变换更容易理解 局部扰动 局部扰动也就是把扰动加在目前的坐标系数据下，然后再通过坐标系之间的关系变到其他坐标系下，具体形式为： q~=q⊗Δq\tilde{q} = q \otimes \Delta q q~​=q⊗Δq R~=RΔR\tilde{R} = R \Delta R R~=RΔR 其扰动放在右边，其原因为qAB′=qAB⊗qBB′q_{AB&#x27;} = q_{AB} \otimes q_{BB&#x27;}qAB′​=qAB​⊗qBB′​，可以满足先对局部数据进行扰动调整再通过坐标系关系变换到其他坐标系下。典型的应用为IMU预积分，具体形式为qGIk+1=qGIk⊗qIkIk+1q_{GI_{k+1}} = q_{GI_{k}} \otimes q_{I_{k}I_{k+1}}qGIk+1​​=qGIk​​⊗qIk​Ik+1​​。旋转矩阵形式类似。其对时间求导形式为： q˙=12Ω(ω)q=12q⊗ω\dot{q} = \frac{1}{2} \Omega(\omega) q = \frac{1}{2} q \otimes \omega q˙​=21​Ω(ω)q=21​q⊗ω R˙=R[ω]×\dot{R} = R[\omega]_{\times} R˙=R[ω]×​ 其中ω\omegaω为局部角速度（当前坐标系的角速度），Ω(ω)\Omega(\omega)Ω(ω)为[ω]R[\omega]_R[ω]R​（不要在意维数的问题）。具体推导如下： q˙=lim⁡Δt→0q(t+Δt)−q(t)Δt=lim⁡Δt→0q⊗Δq−qΔt=lim⁡Δt→0q⊗([1Δθ/2]−[10])Δt=lim⁡Δt→0q⊗([0Δθ/2])Δt=12q⊗[0ωL]R˙=lim⁡Δt→0R(t+Δt)−R(t)Δt=lim⁡Δt→0RΔR−RΔt=lim⁡Δt→0R(ΔR−I)Δt=lim⁡Δt→0R[Δθ]×Δt=R[ω]×\begin{aligned} \dot{q} &amp;= \lim_{\Delta t \rightarrow 0} \frac{q(t + \Delta t) - q(t)}{\Delta t} \\ &amp;= \lim_{\Delta t \rightarrow 0} \frac{q \otimes \Delta q - q}{\Delta t} \\ &amp;= \lim_{\Delta t \rightarrow 0} \frac{q \otimes \left(\begin{bmatrix}1 \\ \Delta \theta/2 \end{bmatrix} - \begin{bmatrix} 1 \\ 0 \end{bmatrix} \right)}{\Delta t} \\ &amp;= \lim_{\Delta t \rightarrow 0} \frac{q \otimes \left(\begin{bmatrix}0 \\ \Delta \theta/2 \end{bmatrix} \right)}{\Delta t} \\ &amp;= \frac{1}{2} q \otimes \begin{bmatrix} 0 \\ \omega_L \end{bmatrix} \\ \\ \dot{R} &amp;= \lim_{\Delta t \rightarrow 0} \frac{R(t + \Delta t) - R(t)}{\Delta t} \\ &amp;= \lim_{\Delta t \rightarrow 0} \frac{R \Delta R - R}{\Delta t} \\ &amp;= \lim_{\Delta t \rightarrow 0} \frac{R (\Delta R - I)}{\Delta t} \\ &amp;= \lim_{\Delta t \rightarrow 0} \frac{R [\Delta \theta]_{\times}} {\Delta t} \\ &amp;= R[\omega]_{\times} \end{aligned} q˙​R˙​=Δt→0lim​Δtq(t+Δt)−q(t)​=Δt→0lim​Δtq⊗Δq−q​=Δt→0lim​Δtq⊗([1Δθ/2​]−[10​])​=Δt→0lim​Δtq⊗([0Δθ/2​])​=21​q⊗[0ωL​​]=Δt→0lim​ΔtR(t+Δt)−R(t)​=Δt→0lim​ΔtRΔR−R​=Δt→0lim​ΔtR(ΔR−I)​=Δt→0lim​ΔtR[Δθ]×​​=R[ω]×​​ 全局扰动 和局部扰动相对，也就是先通过坐标系的关系变换到其他坐标系下再进行扰动。具体形式为： q~=Δq⊗q\tilde{q} = \Delta q \otimes q q~​=Δq⊗q R~=ΔRR\tilde{R} = \Delta R R R~=ΔRR 由于qA′B=qA′AqABq_{A&#x27;B} = q_{A&#x27;A}q_{AB}qA′B​=qA′A​qAB​，也就是扰动没有加在局局部下，是加在了坐标系之间的变换这种全局关系中。其时间导数为： q˙=12[ω]Lq=12ω⊗q\dot{q} = \frac{1}{2} [\omega]_L q = \frac{1}{2} \omega \otimes q q˙​=21​[ω]L​q=21​ω⊗q R˙=[ω]×R\dot{R} = [\omega]_{\times} R R˙=[ω]×​R 其中ω\omegaω是全局角速度，也就是要目标坐标系下的角速度，不是当前坐标系下的角速度。 其他的求导 ∂(q⊗a⊗q∗)∂θ=∂(Ra)∂θ=lim⁡∂θ→0R{θ+∂θ}a−Ra∂θ=lim⁡∂θ→0(I+[∂θ]×)Ra−Ra∂θ=−[Ra]×∂(q⊗a⊗q∗)∂q=∂(Ra)∂q=2[qwa+qv×a∣qvTaI+qvaT−aqvT−qw[a]×]\begin{aligned} \frac{\partial (q \otimes a \otimes q^*)}{\partial \theta} &amp;= \frac{\partial (Ra)}{\partial \theta} \\ &amp;= \lim_{\partial \theta \rightarrow 0} \frac{R\{ \theta + \partial \theta \}a - Ra}{\partial \theta} \\ &amp;= \lim_{\partial \theta \rightarrow 0} \frac{(I + [\partial \theta]_{\times})Ra - Ra}{\partial \theta} \\ &amp;= -\left[ Ra \right]_{\times} \\ \\ \frac{\partial (q \otimes a \otimes q^*)}{\partial q} &amp;= \frac{\partial (Ra)}{\partial q} \\ &amp;= 2 \left[ q_w a + q_v \times a | q_v^T a I + q_v a^T - a q_v^T - q_w [a]_{\times} \right] \end{aligned} ∂θ∂(q⊗a⊗q∗)​∂q∂(q⊗a⊗q∗)​​=∂θ∂(Ra)​=∂θ→0lim​∂θR{θ+∂θ}a−Ra​=∂θ→0lim​∂θ(I+[∂θ]×​)Ra−Ra​=−[Ra]×​=∂q∂(Ra)​=2[qw​a+qv​×a∣qvT​aI+qv​aT−aqvT​−qw​[a]×​]​ 旋转矩阵与四元数关系 （不要在意维数的细节问题） q⊗r⊗q∗=Rrq \otimes r \otimes q^* = Rr q⊗r⊗q∗=Rr R4=[q∗]R[q]L=[q]L[q∗]R=[100R] R_4 = [q^*]_R[q]_L = [q]_L[q^*]_R = \begin{bmatrix} 1 &amp; 0 \\ 0 &amp; R \end{bmatrix} R4​=[q∗]R​[q]L​=[q]L​[q∗]R​=[10​0R​] 系统运动（局部） 连续时间 论文里面多是给的连续时间的推导结果 true state： p˙t=vt\dot{p}_t = v_t p˙​t​=vt​ v˙t=Rt(am−abt−an)+gt\dot{v}_t = R_t(a_m - a_{bt} - a_n) + g_t v˙t​=Rt​(am​−abt​−an​)+gt​ q˙t=12qt⊗(ωm−ωbt−ωn)\dot{q}_t = \frac{1}{2} q_t \otimes (\omega_m - \omega_{bt} - \omega_n) q˙​t​=21​qt​⊗(ωm​−ωbt​−ωn​) a˙bt=aw\dot{a}_{bt} = a_w a˙bt​=aw​ ω˙bt=ωw\dot{\omega}_{bt} = \omega _w ω˙bt​=ωw​ g˙t=0\dot{g}_t = 0 g˙​t​=0 其中ama_mam​与ωm\omega_mωm​为测量值，abta_{bt}abt​与ωbt\omega_{bt}ωbt​为true bias，ana_nan​与ωn\omega_nωn​为噪声。 nominal state： p˙=v\dot{p} = v p˙​=v v˙=R(am−ab)+g\dot{v} = R(a_m - a_b) + g v˙=R(am​−ab​)+g q˙=12q⊗(ωm−ωb)\dot{q} = \frac{1}{2} q \otimes (\omega_m - \omega_b) q˙​=21​q⊗(ωm​−ωb​) a˙b=0\dot{a}_b = 0 a˙b​=0 ω˙b=0\dot{\omega}_b = 0 ω˙b​=0 g˙=0\dot{g} = 0 g˙​=0 error state： δp˙=δv\dot{\delta p} = \delta v δp˙​=δv δv˙=−R[am−ab]×δθ−Rδab+δg−Ran\dot{\delta v} = -R[a_m - a_b]_{\times} \delta \theta - R \delta a_b + \delta g - Ra_n δv˙=−R[am​−ab​]×​δθ−Rδab​+δg−Ran​ δθ˙=−[ωm−ωb]×δθ−δωb−ωn\dot{\delta \theta} = -[\omega_m - \omega_b]_{\times}\delta\theta - \delta \omega_b - \omega_n δθ˙=−[ωm​−ωb​]×​δθ−δωb​−ωn​ δab˙=aw\dot{\delta a_b} = a_w δab​˙​=aw​ ωb˙=ωw\dot{\omega_b} = \omega_w ωb​˙​=ωw​ δg˙=0\dot{\delta g} = 0 δg˙​=0 TODO：δv˙\dot{\delta v}δv˙和δθ˙\dot{\delta \theta}δθ˙的推导有时间补上 离散时间 其实和连续时间没差多少，就是把导数变成已经积分好的x←x+x˙Δtx \leftarrow x + \dot{x}\Delta tx←x+x˙Δt。数值积分方法还可以使用其他的，之后的具体形式都需要重新推导，这里是示例。 nominal state： p←p+vΔt+12(R(am−ab)+g)Δt2p \leftarrow p + v\Delta t + \frac{1}{2} (R(a_m - a_b) + g)\Delta t^2 p←p+vΔt+21​(R(am​−ab​)+g)Δt2 v←v+(R(am−ab)+g)Δtv \leftarrow v + (R(a_m - a_b) + g) \Delta t v←v+(R(am​−ab​)+g)Δt q←q⊗q{(ωm−ωb)Δt}q \leftarrow q \otimes q\{ (\omega_m - \omega_b)\Delta t \} q←q⊗q{(ωm​−ωb​)Δt} ab←aba_b \leftarrow a_b ab​←ab​ ωb←ωb\omega_b \leftarrow \omega_b ωb​←ωb​ g←gg \leftarrow g g←g error state： δp←δp+δvΔt\delta p \leftarrow \delta p + \delta v \Delta t δp←δp+δvΔt δv←δv+(−R[am−ab]×δθ−Rδab+δg)Δt+vi\delta v \leftarrow \delta v + (-R[a_m-a_b]_{\times}\delta \theta - R\delta a_b + \delta g) \Delta t + v_i δv←δv+(−R[am​−ab​]×​δθ−Rδab​+δg)Δt+vi​ δθ←RT{(ωm−ωb)Δt}δθ−δωbΔt+θi\delta \theta \leftarrow R^T\{ (\omega_m - \omega_b) \Delta t \}\delta \theta - \delta \omega_b \Delta t + \theta_i δθ←RT{(ωm​−ωb​)Δt}δθ−δωb​Δt+θi​ δab←δab+ai\delta a_b \leftarrow \delta a_b + a_i δab​←δab​+ai​ δωb←δωb+ωi\delta \omega_b \leftarrow \delta \omega_b + \omega_i δωb​←δωb​+ωi​ δg←δg\delta g \leftarrow \delta g δg←δg FFF矩阵可以通过以上内容很容易推导出来，具体形式懒得写了。 error state的期望为000，在预测的过程中就是为了计算协方差矩阵，改变当前期望分布]]></content>
      <tags>
        <tag>vio</tag>
        <tag>slam</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MSCKF相关问题推导]]></title>
    <url>%2F2018%2F11%2F28%2Fmsckf%2F</url>
    <content type="text"><![CDATA[MSCKF文章中没有给出的推导和一些疑问。 paper链接 这个逼怕是用的左手系哦！！！！！！ 关于状态向量 这个逼的状态向量里面的四元数是从全局坐标系到IMU坐标系变换的GIq^I_GqGI​q，也就是IMU坐标系中全局坐标系的方向，也就是全局坐标系中IMU坐标系方向的逆 方向的true state为：qˉ=δqˉ⊗qˉ^\bar{q} = \delta \bar{q} \otimes \hat{\bar{q}}qˉ​=δqˉ​⊗qˉ​^​ 导数为:q˙=12ω⊗q\dot{q} = \frac{1}{2} \omega \otimes qq˙​=21​ω⊗q，文章中的Ω(ω)\Omega(\omega)Ω(ω)证明了这个是左手系 Jacobian矩阵 相机状态的Jacobian矩阵计算，单位四元数的逆就是其共轭四元数 error state角度的Jacobian，导数第二步推导使用分配律，RICR^C_IRIC​从IMU坐标变换到相机坐标 qˉ^GC=qˉIC⊗qˉ^GI\hat{\bar{q}}^C_G = \bar{q}^C_I \otimes \hat{\bar{q}}^I_G qˉ​^​GC​=qˉ​IC​⊗qˉ​^​GI​ δqˉGC⊗qˉ^GC=qˉIC⊗δqˉGI⊗qˉ^GI\delta \bar{q}^C_G \otimes \hat{\bar{q}}^C_G = \bar{q}^C_I \otimes \delta \bar{q}^I_G \otimes \hat{\bar{q}}^I_G δqˉ​GC​⊗qˉ​^​GC​=qˉ​IC​⊗δqˉ​GI​⊗qˉ​^​GI​ δqˉGC⊗qˉIC=qˉIC⊗δqˉGI\delta \bar{q}^C_G \otimes \bar{q}^C_I = \bar{q}^C_I \otimes \delta \bar{q}^I_G δqˉ​GC​⊗qˉ​IC​=qˉ​IC​⊗δqˉ​GI​ δqˉGC=qˉIC⊗δqˉGI⊗qˉIC∗\delta \bar{q}^C_G = \bar{q}^C_I \otimes \delta \bar{q}^I_G \otimes {\bar{q}^C_I}^* δqˉ​GC​=qˉ​IC​⊗δqˉ​GI​⊗qˉ​IC​∗ [0,0,0,1]+12[δθC,0]=qˉIC⊗12[δθI,0]⊗qˉIC∗+[0,0,0,1][0, 0, 0, 1] + \frac{1}{2}[\delta \theta ^C, 0] = \bar{q}^C_I \otimes \frac{1}{2}[\delta \theta ^I, 0] \otimes {\bar{q}^C_I}^* + [0, 0, 0, 1] [0,0,0,1]+21​[δθC,0]=qˉ​IC​⊗21​[δθI,0]⊗qˉ​IC​∗+[0,0,0,1] ∂δθC∂δθI=RIC\frac{\partial \delta \theta ^C}{\partial \delta \theta ^I} = R^C_I ∂δθI∂δθC​=RIC​ error state坐标的Jacobian（我觉得文章里面推的不对！） p^CG=p^IG+RGITpCI\hat{p}^G_C = \hat{p}^G_I + {R^I_G}^T p^I_C p^​CG​=p^​IG​+RGI​TpCI​ δpCG+pCG=δpIG+pIG+(δRGIRGI)TpCI猜测文章中是：δRGITRGIT\delta p^G_C + p^G_C = \delta p^G_I + p^G_I + \left( \delta R^I_G R^I_G \right)^T p^I_C \quad \text{猜测文章中是：} {\delta R^I_G}^T {R^I_G}^T δpCG​+pCG​=δpIG​+pIG​+(δRGI​RGI​)TpCI​猜测文章中是：δRGI​TRGI​T δpCG=δpIG+RGITδRGITpCI−RGITpCI\delta p^G_C = \delta p^G_I + {R^I_G}^T {\delta R^I_G}^T p^I_C - {R^I_G}^T p^I_C δpCG​=δpIG​+RGI​TδRGI​TpCI​−RGI​TpCI​ δpCG=δpIG−RGIT[δθI]×pCI由于：δRGI=I+[δθI]×+...\delta p^G_C = \delta p^G_I - {R^I_G}^T \left[\delta \theta ^I \right]_{\times} p^I_C \quad \text{由于：} \delta R^I_G = I + \left[\delta \theta ^I \right]_{\times}+ ... δpCG​=δpIG​−RGI​T[δθI]×​pCI​由于：δRGI​=I+[δθI]×​+... δpCG=δpIG+RGIT[pCI]×δθI\delta p^G_C = \delta p^G_I + {R^I_G}^T \left[ p^I_C \right]_{\times} \delta \theta ^I δpCG​=δpIG​+RGI​T[pCI​]×​δθI ∂δpCG∂δpIG=I\frac{\partial \delta p^G_C}{\partial \delta p^G_I} = I ∂δpIG​∂δpCG​​=I ∂δpCG∂δθI=RGIT[pCI]×\frac{\partial \delta p^G_C}{\partial \delta \theta ^I} = {R^I_G}^T \left[p^I_C \right]_{\times} ∂δθI∂δpCG​​=RGI​T[pCI​]×​ Update 根据残差方程 r=HX~+noiser = H \widetilde{X} + noise r=HX+noise 计算error state，先计算特征点重投影误差和Jacobian矩阵，然后再计算error state 计算特征点坐标 多个相机由feature约束，map: feature -&gt; {camera} 特征点的像素 z=1Z[XY]+n z = \frac{1}{Z} \begin{bmatrix} X \\ Y \end{bmatrix} + n z=Z1​[XY​]+n 特征点在相机坐标系中的坐标有 pf=[XYZ]=R(pf−pC) p_f = \begin{bmatrix} X \\ Y \\ Z\end {bmatrix} = R(p_f - p_C) pf​=⎣⎡​XYZ​⎦⎤​=R(pf​−pC​) 使用最小二乘解得到特征点坐标 先使用首尾两帧三角交汇得到初始解，先通过像素坐标（归一化平面）获得投影方向（各自相机的坐标系）单位长度向量d1d1d1与d2d2d2，即 (u,v,f)→(uf,vf,1)→(u,v,f).normalize()(u,v,f) \rightarrow (\frac{u}{f}, \frac{v}{f}, 1) \rightarrow (u,v,f).normalize() (u,v,f)→(fu​,fv​,1)→(u,v,f).normalize() 然后获取相机C1C_1C1​到C2C_2C2​的旋转矩阵RRR与平移ttt，有 x1d1=t+RTx2d2x_1 d_1 = t + R^T x_2 d_2 x1​d1​=t+RTx2​d2​ t=d1x1−RTd2x2t = d_1 x_1 - R^T d_2 x_2 t=d1​x1​−RTd2​x2​ [d1−RTd2][x1x2]=t \begin{bmatrix} d_1 &amp; - R^T d_2 \end{bmatrix} \begin{bmatrix} x_1 \\ x_2 \end{bmatrix} = t [d1​​−RTd2​​][x1​x2​​]=t 则x1d1x_1 d_1x1​d1​为特征点在第一个相机的坐标系中的坐标，以此坐标为初始值再利用其他帧数据计算特征点坐标 逆深度参数： (u,v,f)→(u/f,v/f,1/f)(u,v,f) \rightarrow (u/f,v/f,1/f)(u,v,f)→(u/f,v/f,1/f)，逆深度的逆深度是本身 由计算得到的坐标与相机参数得到重投影误差 计算误差Jacobian 重投影误差线性化有 ri(j)≃HXi(j)X~+Hfi(j)GP~fi+ni(j)r^{(j)}_i \simeq H^{(j)}_{X_i} \widetilde{X} + H^{(j)}_{f_i} {}^G\widetilde{P}_{f_i} + n^{(j)}_i ri(j)​≃HXi​(j)​X+Hfi​(j)​GPfi​​+ni(j)​ 其中 HXi(j)=[02×1502×6⋯Ji(j)⌊CiX^fi×⌋−Ji(j)C(GCiqˉ^)⎵Jacobian wrt pose i⋯] H^{(j)}_{X_i} = \begin{bmatrix} 0_{2 \times 15} &amp; 0_{2 \times 6} &amp; \cdots &amp; \underbrace{\begin{matrix} J^{(j)}_i \lfloor {}^{C_i}\hat{X}_{f_i} \times \rfloor &amp; -J^{(j)}_i C({}_G^{C_i}\hat{\bar{q}}) \end{matrix}}_{Jacobian \ wrt \ pose \ i} &amp; \cdots \end{bmatrix} HXi​(j)​=[02×15​​02×6​​⋯​Jacobian wrt pose iJi(j)​⌊Ci​X^fi​​×⌋​−Ji(j)​C(GCi​​qˉ​^​)​​​​⋯​] 与 Hfi(j)=Ji(j)C(GCiqˉ^)H^{(j)}_{f_i} = J^{(j)}_i C({}_G^{C_i}\hat{\bar{q}}) Hfi​(j)​=Ji(j)​C(GCi​​qˉ​^​) 且有 Ji(j)=∇Cip^fjzi(j)=1CiZ^j[10−CiX^jCiZ^j01−CiY^jCiZ^j] J^{(j)}_i = \nabla_{ {C_i}_{\hat{p}_{f_j} } } z^{(j)}_i = \frac{1}{C_i \hat{Z}_j} \begin{bmatrix} 1 &amp; 0 &amp; - \frac{C_i\hat{X}_j}{C_i\hat{Z}_j} \\ 0 &amp; 1 &amp; - \frac{C_i\hat{Y}_j}{C_i\hat{Z}_j} \end{bmatrix} Ji(j)​=∇Ci​p^​fj​​​​zi(j)​=Ci​Z^j​1​⎣⎡​10​01​−Ci​Z^j​Ci​X^j​​−Ci​Z^j​Ci​Y^j​​​⎦⎤​ 将r(j)r^{(j)}r(j)投影到Hf(j)H^{(j)}_fHf(j)​的左零空间，有 ro(j)≃ATHX(j)X~+ATn(j)=H0(j)X~(j)+n0(j)r_o^{(j)} \simeq A^T H^{(j)}_X \widetilde{X} + A^T n^{(j)} = H^{(j)}_0 \widetilde{X}^{(j)} + n^{(j)}_0 ro(j)​≃ATHX(j)​X+ATn(j)=H0(j)​X(j)+n0(j)​ 由于Hf(j)H^{(j)}_fHf(j)​是2Mj×32M_j \times 32Mj​×3满秩矩阵，其左零空间维数为2Mj−32M_j - 32Mj​−3 Update 由于Jacobian矩阵维度很高，因此考虑使用QR分解降低维度，然后使用标准的EKF更新状态和协方差矩阵]]></content>
      <tags>
        <tag>vio</tag>
        <tag>slam</tag>
      </tags>
  </entry>
</search>
