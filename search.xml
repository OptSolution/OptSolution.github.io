<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[四元数及error-state kalman]]></title>
    <url>%2F2018%2F11%2F28%2FQuaternion-kinematics%2F</url>
    <content type="text"><![CDATA[四元数相关的基本推导，主要是扰动相关。然后记下了一些error-state kalman相关的公式。 不做具体说明时，都是右手系 四元数乘法 q⊗p≠p⊗qq \otimes p \neq p \otimes q q⊗p≠p⊗q 其中⊗\otimes⊗为四元数乘法，ppp和qqq为四元数，四元数乘法满足结合律和分配律。四元数乘法为二元运算，可以写成两种等价的形式： q⊗p=[q]Lp=[p]Rqq \otimes p = {[q]}_L p = {[p]}_Rq q⊗p=[q]L​p=[p]R​q [q]L=qwI+[0−qvTqv[qv]×][q]_L = q_wI + \begin{bmatrix} 0 &amp; -q_v^T \\ q_v &amp; [q_v]_{\times} \end{bmatrix} [q]L​=qw​I+[0qv​​−qvT​[qv​]×​​] [q]R=qwI+[0−qvTqv−[qv]×][q]_R = q_wI + \begin{bmatrix} 0 &amp; -q_v^T \\ q_v &amp; -[q_v]_{\times} \end{bmatrix} [q]R​=qw​I+[0qv​​−qvT​−[qv​]×​​] 其中q=(qw,qv)q = (q_w, q_v)q=(qw​,qv​)，qwq_wqw​为实数，qvq_vqv​为其中虚数向量。 左手系和右手系在四元数计算上的区别： 右手系：ij=−ji=kij = -ji = kij=−ji=k， jk=−kj=ijk = -kj = ijk=−kj=i，ki=−ik=jki = -ik = jki=−ik=j 左手系：ij=−ji=−kij = -ji = -kij=−ji=−k，jk=−kj=−ijk = -kj = -ijk=−kj=−i，ki=−ik=−jki = -ik = -jki=−ik=−j Eigen中的四元数运算如果使用方法 coeffs()输出系数，输出的向量是按照(qv,qw)(q_v,q_w)(qv​,qw​)排列的。在Eigen中四元数的构造函数中，输入参数顺序是按照(qw,qv)(q_w,q_v)(qw​,qv​)排列的。所以想使用四元数乘法的时候可以构造四元数使用Eigen的四元数相乘函数来避免这些问题。但是想使用Eigen的四元数系数进行四元数乘法运算时（尤其对于论文里面经常提到的Ω\OmegaΩ矩阵），其形式为 [q]L=qwI+[[qv]×qv−qvT0][q]_L = q_wI +\begin{bmatrix}[q_v]_{\times} &amp; q_v \\-q_v^T &amp; 0\end{bmatrix}[q]L​=qw​I+[[qv​]×​−qvT​​qv​0​] [q]R=qwI+[−[qv]×qv−qvT0][q]_R = q_wI +\begin{bmatrix}-[q_v]_{\times} &amp; q_v \\-q_v^T &amp; 0\end{bmatrix}[q]R​=qw​I+[−[qv​]×​−qvT​​qv​0​] 当然计算结果自然是按照(qv,qw)(q_v,q_w)(qv​,qw​)排列的四元数 由于 q⊗r⊗p=[p]R[q]Lrq \otimes r \otimes p = [p]_R[q]_Lr q⊗r⊗p=[p]R​[q]L​r q⊗r⊗p=[q]L[p]Rrq \otimes r \otimes p = [q]_L[p]_Rr q⊗r⊗p=[q]L​[p]R​r 因此有[p]R[q]L=[q]L[p]R[p]_R[q]_L = [q]_L[p]_R[p]R​[q]L​=[q]L​[p]R​ 扰动及求导 先交代一些东西 qAB⊗qBC=qACq_{AB} \otimes q_{BC} = q_{AC} qAB​⊗qBC​=qAC​ RABRBC=RACR_{AB} R_{BC} = R_{AC} RAB​RBC​=RAC​ Δq=[112Δθ]+O(∥Δθ∥2)\Delta q = \begin{bmatrix} 1 \\ \frac{1}{2} \Delta \theta \end{bmatrix} + O \left( \| \Delta \theta \|^2 \right) Δq=[121​Δθ​]+O(∥Δθ∥2) ΔR=I+[Δθ]×+O(∥Δθ∥2)\Delta R = I + [\Delta \theta]_{\times} + O\left( \| \Delta \theta \|^2 \right) ΔR=I+[Δθ]×​+O(∥Δθ∥2) 下文可能使用局部到全局坐标系的变换更容易理解 局部扰动 局部扰动也就是把扰动加在目前的坐标系数据下，然后再通过坐标系之间的关系变到其他坐标系下，具体形式为： q~=q⊗Δq\tilde{q} = q \otimes \Delta q q~​=q⊗Δq R~=RΔR\tilde{R} = R \Delta R R~=RΔR 其扰动放在右边，其原因为qAB′=qAB⊗qBB′q_{AB&#x27;} = q_{AB} \otimes q_{BB&#x27;}qAB′​=qAB​⊗qBB′​，可以满足先对局部数据进行扰动调整再通过坐标系关系变换到其他坐标系下。典型的应用为IMU预积分，具体形式为qGIk+1=qGIk⊗qIkIk+1q_{GI_{k+1}} = q_{GI_{k}} \otimes q_{I_{k}I_{k+1}}qGIk+1​​=qGIk​​⊗qIk​Ik+1​​。旋转矩阵形式类似。其对时间求导形式为： q˙=12Ω(ω)q=12q⊗ω\dot{q} = \frac{1}{2} \Omega(\omega) q = \frac{1}{2} q \otimes \omega q˙​=21​Ω(ω)q=21​q⊗ω R˙=R[ω]×\dot{R} = R[\omega]_{\times} R˙=R[ω]×​ 其中ω\omegaω为局部角速度（当前坐标系的角速度），Ω(ω)\Omega(\omega)Ω(ω)为[ω]R[\omega]_R[ω]R​（不要在意维数的问题）。具体推导如下： q˙=lim⁡Δt→0q(t+Δt)−q(t)Δt=lim⁡Δt→0q⊗Δq−qΔt=lim⁡Δt→0q⊗([1Δθ/2]−[10])Δt=lim⁡Δt→0q⊗([0Δθ/2])Δt=12q⊗[0ωL]\dot{q} = \lim_{\Delta t \rightarrow 0} \frac{q(t + \Delta t) - q(t)}{\Delta t} = \lim_{\Delta t \rightarrow 0} \frac{q \otimes \Delta q - q}{\Delta t} = \lim_{\Delta t \rightarrow 0} \frac{q \otimes \left(\begin{bmatrix}1 \\ \Delta \theta/2 \end{bmatrix} - \begin{bmatrix} 1 \\ 0 \end{bmatrix} \right)}{\Delta t} = \lim_{\Delta t \rightarrow 0} \frac{q \otimes \left(\begin{bmatrix}0 \\ \Delta \theta/2 \end{bmatrix} \right)}{\Delta t} = \frac{1}{2} q \otimes \begin{bmatrix} 0 \\ \omega_L \end{bmatrix} q˙​=Δt→0lim​Δtq(t+Δt)−q(t)​=Δt→0lim​Δtq⊗Δq−q​=Δt→0lim​Δtq⊗([1Δθ/2​]−[10​])​=Δt→0lim​Δtq⊗([0Δθ/2​])​=21​q⊗[0ωL​​] R˙=lim⁡Δt→0R(t+Δt)−R(t)Δt=lim⁡Δt→0RΔR−RΔt=lim⁡Δt→0R(ΔR−I)Δt=lim⁡Δt→0R[Δθ]×Δt=R[ω]×\dot{R} = \lim_{\Delta t \rightarrow 0} \frac{R(t + \Delta t) - R(t)}{\Delta t} = \lim_{\Delta t \rightarrow 0} \frac{R \Delta R - R}{\Delta t} = \lim_{\Delta t \rightarrow 0} \frac{R (\Delta R - I)}{\Delta t} = \lim_{\Delta t \rightarrow 0} \frac{R [\Delta \theta]_{\times}}{\Delta t} = R[\omega]_{\times} R˙=Δt→0lim​ΔtR(t+Δt)−R(t)​=Δt→0lim​ΔtRΔR−R​=Δt→0lim​ΔtR(ΔR−I)​=Δt→0lim​ΔtR[Δθ]×​​=R[ω]×​ 全局扰动 和局部扰动相对，也就是先通过坐标系的关系变换到其他坐标系下再进行扰动。具体形式为： q~=Δq⊗q\tilde{q} = \Delta q \otimes q q~​=Δq⊗q R~=ΔRR\tilde{R} = \Delta R R R~=ΔRR 由于qA′B=qA′AqABq_{A&#x27;B} = q_{A&#x27;A}q_{AB}qA′B​=qA′A​qAB​，也就是扰动没有加在局局部下，是加在了坐标系之间的变换这种全局关系中。其时间导数为： q˙=12[ω]Lq=12ω⊗q\dot{q} = \frac{1}{2} [\omega]_L q = \frac{1}{2} \omega \otimes q q˙​=21​[ω]L​q=21​ω⊗q R˙=[ω]×R\dot{R} = [\omega]_{\times} R R˙=[ω]×​R 其中ω\omegaω是全局角速度，也就是要目标坐标系下的角速度，不是当前坐标系下的角速度。 其他的求导 ∂(q⊗a⊗q∗)∂θ=∂(Ra)∂θ=lim⁡∂θ→0R{θ+∂θ}a−Ra∂θ=lim⁡∂θ→0(I+[∂θ]×)Ra−Ra∂θ=−[Ra]×\frac{\partial (q \otimes a \otimes q^*)}{\partial \theta} = \frac{\partial (Ra)}{\partial \theta} = \lim_{\partial \theta \rightarrow 0} \frac{R\{ \theta + \partial \theta \}a - Ra}{\partial \theta} = \lim_{\partial \theta \rightarrow 0} \frac{(I + [\partial \theta]_{\times})Ra - Ra}{\partial \theta} = -\left[ Ra \right]_{\times} ∂θ∂(q⊗a⊗q∗)​=∂θ∂(Ra)​=∂θ→0lim​∂θR{θ+∂θ}a−Ra​=∂θ→0lim​∂θ(I+[∂θ]×​)Ra−Ra​=−[Ra]×​ ∂(q⊗a⊗q∗)∂q=∂(Ra)∂q=2[qwa+qv×a∣qvTaI+qvaT−aqvT−qw[a]×]\frac{\partial (q \otimes a \otimes q^*)}{\partial q} = \frac{\partial (Ra)}{\partial q} = 2 \left[ q_w a + q_v \times a | q_v^T a I + q_v a^T - a q_v^T - q_w [a]_{\times} \right] ∂q∂(q⊗a⊗q∗)​=∂q∂(Ra)​=2[qw​a+qv​×a∣qvT​aI+qv​aT−aqvT​−qw​[a]×​] 旋转矩阵与四元数关系 （不要在意维数的细节问题） q⊗r⊗q∗=Rrq \otimes r \otimes q^* = Rr q⊗r⊗q∗=Rr R4=[q∗]R[q]L=[q]L[q∗]R=[100R] R_4 = [q^*]_R[q]_L = [q]_L[q^*]_R = \begin{bmatrix} 1 &amp; 0 \\ 0 &amp; R \end{bmatrix} R4​=[q∗]R​[q]L​=[q]L​[q∗]R​=[10​0R​] 系统运动（局部） 连续时间 论文里面多是给的连续时间的推导结果 true state： p˙t=vt\dot{p}_t = v_t p˙​t​=vt​ v˙t=Rt(am−abt−an)+gt\dot{v}_t = R_t(a_m - a_{bt} - a_n) + g_t v˙t​=Rt​(am​−abt​−an​)+gt​ q˙t=12qt⊗(ωm−ωbt−ωn)\dot{q}_t = \frac{1}{2} q_t \otimes (\omega_m - \omega_{bt} - \omega_n) q˙​t​=21​qt​⊗(ωm​−ωbt​−ωn​) a˙bt=aw\dot{a}_{bt} = a_w a˙bt​=aw​ ω˙bt=ωw\dot{\omega}_{bt} = \omega _w ω˙bt​=ωw​ g˙t=0\dot{g}_t = 0 g˙​t​=0 其中ama_mam​与ωm\omega_mωm​为测量值，abta_{bt}abt​与ωbt\omega_{bt}ωbt​为true bias，ana_nan​与ωn\omega_nωn​为噪声。 nominal state： p˙=v\dot{p} = v p˙​=v v˙=R(am−ab)+g\dot{v} = R(a_m - a_b) + g v˙=R(am​−ab​)+g q˙=12q⊗(ωm−ωb)\dot{q} = \frac{1}{2} q \otimes (\omega_m - \omega_b) q˙​=21​q⊗(ωm​−ωb​) a˙b=0\dot{a}_b = 0 a˙b​=0 ω˙b=0\dot{\omega}_b = 0 ω˙b​=0 g˙=0\dot{g} = 0 g˙​=0 error state： δp˙=δv\dot{\delta p} = \delta v δp˙​=δv δv˙=−R[am−ab]×δθ−Rδab+δg−Ran\dot{\delta v} = -R[a_m - a_b]_{\times} \delta \theta - R \delta a_b + \delta g - Ra_n δv˙=−R[am​−ab​]×​δθ−Rδab​+δg−Ran​ δθ˙=−[ωm−ωb]×δθ−δωb−ωn\dot{\delta \theta} = -[\omega_m - \omega_b]_{\times}\delta\theta - \delta \omega_b - \omega_n δθ˙=−[ωm​−ωb​]×​δθ−δωb​−ωn​ δab˙=aw\dot{\delta a_b} = a_w δab​˙​=aw​ ωb˙=ωw\dot{\omega_b} = \omega_w ωb​˙​=ωw​ δg˙=0\dot{\delta g} = 0 δg˙​=0 TODO：δv˙\dot{\delta v}δv˙和δθ˙\dot{\delta \theta}δθ˙的推导有时间补上 离散时间 其实和连续时间没差多少，就是把导数变成已经积分好的x←x+x˙Δtx \leftarrow x + \dot{x}\Delta tx←x+x˙Δt。数值积分方法还可以使用其他的，之后的具体形式都需要重新推导，这里是示例。 nominal state： p←p+vΔt+12(R(am−ab)+g)Δt2p \leftarrow p + v\Delta t + \frac{1}{2} (R(a_m - a_b) + g)\Delta t^2 p←p+vΔt+21​(R(am​−ab​)+g)Δt2 v←v+(R(am−ab)+g)Δtv \leftarrow v + (R(a_m - a_b) + g) \Delta t v←v+(R(am​−ab​)+g)Δt q←q⊗q{(ωm−ωb)Δt}q \leftarrow q \otimes q\{ (\omega_m - \omega_b)\Delta t \} q←q⊗q{(ωm​−ωb​)Δt} ab←aba_b \leftarrow a_b ab​←ab​ ωb←ωb\omega_b \leftarrow \omega_b ωb​←ωb​ g←gg \leftarrow g g←g error state： δp←δp+δvΔt\delta p \leftarrow \delta p + \delta v \Delta t δp←δp+δvΔt δv←δv+(−R[am−ab]×δθ−Rδab+δg)Δt+vi\delta v \leftarrow \delta v + (-R[a_m-a_b]_{\times}\delta \theta - R\delta a_b + \delta g) \Delta t + v_i δv←δv+(−R[am​−ab​]×​δθ−Rδab​+δg)Δt+vi​ δθ←RT{(ωm−ωb)Δt}δθ−δωbΔt+θi\delta \theta \leftarrow R^T\{ (\omega_m - \omega_b) \Delta t \}\delta \theta - \delta \omega_b \Delta t + \theta_i δθ←RT{(ωm​−ωb​)Δt}δθ−δωb​Δt+θi​ δab←δab+ai\delta a_b \leftarrow \delta a_b + a_i δab​←δab​+ai​ δωb←δωb+ωi\delta \omega_b \leftarrow \delta \omega_b + \omega_i δωb​←δωb​+ωi​ δg←δg\delta g \leftarrow \delta g δg←δg FFF矩阵可以通过以上内容很容易推导出来，具体形式懒得写了。 error state的期望为000，在预测的过程中就是为了计算协方差矩阵，改变当前期望分布]]></content>
      <tags>
        <tag>math</tag>
        <tag>vio</tag>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MSCKF相关问题推导]]></title>
    <url>%2F2018%2F11%2F28%2Fmsckf%2F</url>
    <content type="text"><![CDATA[MSCKF文章中没有给出的推导和一些疑问。 paper链接 这个逼怕是用的左手系哦！！！！！！ 关于状态向量 这个逼的状态向量里面的四元数是从全局坐标系到IMU坐标系变换的GIq^I_GqGI​q，也就是IMU坐标系中全局坐标系的方向，也就是全局坐标系中IMU坐标系方向的逆 方向的true state为：qˉ=δqˉ⊗qˉ^\bar{q} = \delta \bar{q} \otimes \hat{\bar{q}}qˉ​=δqˉ​⊗qˉ​^​ 导数为:q˙=12ω⊗q\dot{q} = \frac{1}{2} \omega \otimes qq˙​=21​ω⊗q，文章中的Ω(ω)\Omega(\omega)Ω(ω)证明了这个是左手系 Jacobian矩阵 相机状态的Jacobian矩阵计算，单位四元数的逆就是其共轭四元数 error state角度的Jacobian，导数第二步推导使用分配律，RICR^C_IRIC​从IMU坐标变换到相机坐标 qˉ^GC=qˉIC⊗qˉ^GI\hat{\bar{q}}^C_G = \bar{q}^C_I \otimes \hat{\bar{q}}^I_G qˉ​^​GC​=qˉ​IC​⊗qˉ​^​GI​ δqˉGC⊗qˉ^GC=qˉIC⊗δqˉGI⊗qˉ^GI\delta \bar{q}^C_G \otimes \hat{\bar{q}}^C_G = \bar{q}^C_I \otimes \delta \bar{q}^I_G \otimes \hat{\bar{q}}^I_G δqˉ​GC​⊗qˉ​^​GC​=qˉ​IC​⊗δqˉ​GI​⊗qˉ​^​GI​ δqˉGC⊗qˉIC=qˉIC⊗δqˉGI\delta \bar{q}^C_G \otimes \bar{q}^C_I = \bar{q}^C_I \otimes \delta \bar{q}^I_G δqˉ​GC​⊗qˉ​IC​=qˉ​IC​⊗δqˉ​GI​ δqˉGC=qˉIC⊗δqˉGI⊗qˉIC∗\delta \bar{q}^C_G = \bar{q}^C_I \otimes \delta \bar{q}^I_G \otimes {\bar{q}^C_I}^* δqˉ​GC​=qˉ​IC​⊗δqˉ​GI​⊗qˉ​IC​∗ [0,0,0,1]+12[δθC,0]=qˉIC⊗12[δθI,0]⊗qˉIC∗+[0,0,0,1][0, 0, 0, 1] + \frac{1}{2}[\delta \theta ^C, 0] = \bar{q}^C_I \otimes \frac{1}{2}[\delta \theta ^I, 0] \otimes {\bar{q}^C_I}^* + [0, 0, 0, 1] [0,0,0,1]+21​[δθC,0]=qˉ​IC​⊗21​[δθI,0]⊗qˉ​IC​∗+[0,0,0,1] ∂δθC∂δθI=RIC\frac{\partial \delta \theta ^C}{\partial \delta \theta ^I} = R^C_I ∂δθI∂δθC​=RIC​ error state坐标的Jacobian（我觉得文章里面推的不对！） p^CG=p^IG+RGITpCI\hat{p}^G_C = \hat{p}^G_I + {R^I_G}^T p^I_C p^​CG​=p^​IG​+RGI​TpCI​ δpCG+pCG=δpIG+pIG+(δRGIRGI)TpCI猜测文章中是：δRGITRGIT\delta p^G_C + p^G_C = \delta p^G_I + p^G_I + \left( \delta R^I_G R^I_G \right)^T p^I_C \quad \text{猜测文章中是：} {\delta R^I_G}^T {R^I_G}^T δpCG​+pCG​=δpIG​+pIG​+(δRGI​RGI​)TpCI​猜测文章中是：δRGI​TRGI​T δpCG=δpIG+RGITδRGITpCI−RGITpCI\delta p^G_C = \delta p^G_I + {R^I_G}^T {\delta R^I_G}^T p^I_C - {R^I_G}^T p^I_C δpCG​=δpIG​+RGI​TδRGI​TpCI​−RGI​TpCI​ δpCG=δpIG−RGIT[δθI]×pCI由于：δRGI=I+[δθI]×+...\delta p^G_C = \delta p^G_I - {R^I_G}^T \left[\delta \theta ^I \right]_{\times} p^I_C \quad \text{由于：} \delta R^I_G = I + \left[\delta \theta ^I \right]_{\times}+ ... δpCG​=δpIG​−RGI​T[δθI]×​pCI​由于：δRGI​=I+[δθI]×​+... δpCG=δpIG+RGIT[pCI]×δθI\delta p^G_C = \delta p^G_I + {R^I_G}^T \left[ p^I_C \right]_{\times} \delta \theta ^I δpCG​=δpIG​+RGI​T[pCI​]×​δθI ∂δpCG∂δpIG=I\frac{\partial \delta p^G_C}{\partial \delta p^G_I} = I ∂δpIG​∂δpCG​​=I ∂δpCG∂δθI=RGIT[pCI]×\frac{\partial \delta p^G_C}{\partial \delta \theta ^I} = {R^I_G}^T \left[p^I_C \right]_{\times} ∂δθI∂δpCG​​=RGI​T[pCI​]×​ Update 根据残差方程 r=HX~+noiser = H \widetilde{X} + noise r=HX+noise 计算error state，先计算特征点重投影误差和Jacobian矩阵，然后再计算error state 计算特征点坐标 多个相机由feature约束，map: feature -&gt; {camera} 特征点的像素 z=1Z[XY]+n z = \frac{1}{Z} \begin{bmatrix} X \\ Y \end{bmatrix} + n z=Z1​[XY​]+n 特征点在相机坐标系中的坐标有 pf=[XYZ]=R(pf−pC) p_f = \begin{bmatrix} X \\ Y \\ Z\end {bmatrix} = R(p_f - p_C) pf​=⎣⎡​XYZ​⎦⎤​=R(pf​−pC​) 使用最小二乘解得到特征点坐标 先使用首尾两帧三角交汇得到初始解，先通过像素坐标（归一化平面）获得投影方向（各自相机的坐标系）单位长度向量d1d1d1与d2d2d2，即 (u,v,f)→(uf,vf,1)→(u,v,f).normalize()(u,v,f) \rightarrow (\frac{u}{f}, \frac{v}{f}, 1) \rightarrow (u,v,f).normalize() (u,v,f)→(fu​,fv​,1)→(u,v,f).normalize() 然后获取相机C1C_1C1​到C2C_2C2​的旋转矩阵RRR与平移ttt，有 x1d1=t+RTx2d2x_1 d_1 = t + R^T x_2 d_2 x1​d1​=t+RTx2​d2​ t=d1x1−RTd2x2t = d_1 x_1 - R^T d_2 x_2 t=d1​x1​−RTd2​x2​ [d1−RTd2][x1x2]=t \begin{bmatrix} d_1 &amp; - R^T d_2 \end{bmatrix} \begin{bmatrix} x_1 \\ x_2 \end{bmatrix} = t [d1​​−RTd2​​][x1​x2​​]=t 则x1d1x_1 d_1x1​d1​为特征点在第一个相机的坐标系中的坐标，以此坐标为初始值再利用其他帧数据计算特征点坐标 逆深度参数： (u,v,f)→(u/f,v/f,1/f)(u,v,f) \rightarrow (u/f,v/f,1/f)(u,v,f)→(u/f,v/f,1/f)，逆深度的逆深度是本身 由计算得到的坐标与相机参数得到重投影误差 计算误差Jacobian 重投影误差线性化有 ri(j)≃HXi(j)X~+Hfi(j)GP~fi+ni(j)r^{(j)}_i \simeq H^{(j)}_{X_i} \widetilde{X} + H^{(j)}_{f_i} {}^G\widetilde{P}_{f_i} + n^{(j)}_i ri(j)​≃HXi​(j)​X+Hfi​(j)​GPfi​​+ni(j)​ 其中 HXi(j)=[02×1502×6⋯Ji(j)⌊CiX^fi×⌋−Ji(j)C(GCiqˉ^)⎵Jacobian wrt pose i⋯] H^{(j)}_{X_i} = \begin{bmatrix} 0_{2 \times 15} &amp; 0_{2 \times 6} &amp; \cdots &amp; \underbrace{\begin{matrix} J^{(j)}_i \lfloor {}^{C_i}\hat{X}_{f_i} \times \rfloor &amp; -J^{(j)}_i C({}_G^{C_i}\hat{\bar{q}}) \end{matrix}}_{Jacobian \ wrt \ pose \ i} &amp; \cdots \end{bmatrix} HXi​(j)​=[02×15​​02×6​​⋯​Jacobian wrt pose iJi(j)​⌊Ci​X^fi​​×⌋​−Ji(j)​C(GCi​​qˉ​^​)​​​​⋯​] 与 Hfi(j)=Ji(j)C(GCiqˉ^)H^{(j)}_{f_i} = J^{(j)}_i C({}_G^{C_i}\hat{\bar{q}}) Hfi​(j)​=Ji(j)​C(GCi​​qˉ​^​) 且有 Ji(j)=∇Cip^fjzi(j)=1CiZ^j[10−CiX^jCiZ^j01−CiY^jCiZ^j] J^{(j)}_i = \nabla_{ {C_i}_{\hat{p}_{f_j} } } z^{(j)}_i = \frac{1}{C_i \hat{Z}_j} \begin{bmatrix} 1 &amp; 0 &amp; - \frac{C_i\hat{X}_j}{C_i\hat{Z}_j} \\ 0 &amp; 1 &amp; - \frac{C_i\hat{Y}_j}{C_i\hat{Z}_j} \end{bmatrix} Ji(j)​=∇Ci​p^​fj​​​​zi(j)​=Ci​Z^j​1​⎣⎡​10​01​−Ci​Z^j​Ci​X^j​​−Ci​Z^j​Ci​Y^j​​​⎦⎤​ 将r(j)r^{(j)}r(j)投影到Hf(j)H^{(j)}_fHf(j)​的左零空间，有 ro(j)≃ATHX(j)X~+ATn(j)=H0(j)X~(j)+n0(j)r_o^{(j)} \simeq A^T H^{(j)}_X \widetilde{X} + A^T n^{(j)} = H^{(j)}_0 \widetilde{X}^{(j)} + n^{(j)}_0 ro(j)​≃ATHX(j)​X+ATn(j)=H0(j)​X(j)+n0(j)​ 由于Hf(j)H^{(j)}_fHf(j)​是2Mj×32M_j \times 32Mj​×3满秩矩阵，其左零空间维数为2Mj−32M_j - 32Mj​−3 Update 由于Jacobian矩阵维度很高，因此考虑使用QR分解降低维度，然后使用标准的EKF更新状态和协方差矩阵]]></content>
      <tags>
        <tag>vio</tag>
        <tag>slam</tag>
      </tags>
  </entry>
</search>
