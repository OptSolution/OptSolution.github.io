<!DOCTYPE html><html class="theme-next mist use-motion" lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0">
  <meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="google-site-verification" content="vy8ADMgbPTo-rwRLZ2e8goCHpO5Uzu-DusPhQOWd1O4">



  <meta name="msvalidate.01" content="EE97FA3DD86562235532E9F70B21A815">















  
  
  
  

  
    
    
  

  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.loli.net/css?family=Roboto Slab:300,300italic,400,400italic,700,700italic|Merienda:300,300italic,400,400italic,700,700italic|Ubuntu Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=6.5.0">


  <link rel="mask-icon" href="/images/safari-pinned-tab.svg?v=6.5.0" color="#222">



  <meta name="msapplication-config" content="/images/browserconfig.xml">







<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.5.0',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  



</head><body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">
  <meta name="description" content="statismo中statismo-build-shape-model程序代码的解读 总结一下就是：给出参考帧（因为PCA需要先中心化）之后PCA">
<meta name="keywords" content="statismo,code,SSM">
<meta property="og:type" content="article">
<meta property="og:title" content="statismo代码分析--statismo-build-shape-model">
<meta property="og:url" content="https://optsolution.github.io/archives/34417.html">
<meta property="og:site_name" content="HyperPlane">
<meta property="og:description" content="statismo中statismo-build-shape-model程序代码的解读 总结一下就是：给出参考帧（因为PCA需要先中心化）之后PCA">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-12-18T12:50:17.046Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="statismo代码分析--statismo-build-shape-model">
<meta name="twitter:description" content="statismo中statismo-build-shape-model程序代码的解读 总结一下就是：给出参考帧（因为PCA需要先中心化）之后PCA">



  <link rel="alternate" href="/atom.xml" title="HyperPlane" type="application/atom+xml">




  <link rel="canonical" href="https://optsolution.github.io/archives/34417.html">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>statismo代码分析--statismo-build-shape-model | HyperPlane</title>
  











  <meta name="generator" content="Hexo 3.8.0"><noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>





  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><meta name="generator" content="Hexo 3.8.0"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">HyperPlane</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <h1 class="site-subtitle" itemprop="description">假装喜欢做笔记</h1>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives menu-item-active">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  

<link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/KaTeX/0.9.0/katex.min.css">
</div>
    </header>

    <meta name="generator" content="Hexo 3.8.0">

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://optsolution.github.io/archives/34417.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="OptSolution">
      <meta itemprop="description" content="做每一件有意义的小事">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HyperPlane">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">statismo代码分析--statismo-build-shape-model
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-30 19:33:11" itemprop="dateCreated datePublished" datetime="2018-11-30T19:33:11+08:00">2018-11-30</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-18 20:50:17" itemprop="dateModified" datetime="2018-12-18T20:50:17+08:00">2018-12-18</time>
              
            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon">
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          

          

          
              <div>
              <div class="addthis_inline_share_toolbox"></div>
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <meta name="generator" content="Hexo 3.8.0"><p>statismo中<em>statismo-build-shape-model</em>程序代码的解读</p>
<p>总结一下就是：给出参考帧（因为PCA需要先中心化）之后PCA</p>
<a id="more"></a>
<h2 id="流程图"><a class="markdownIt-Anchor" href="#流程图"></a> 流程图</h2>
<div id="flowchart-0" class="flow-chart"></div>
<hr>
<h2 id="命令行参数"><a class="markdownIt-Anchor" href="#命令行参数"></a> 命令行参数</h2>
<ul>
<li>-l, --data-list DATA_LIST ：指定一个文件路径，这个文件包含所有用来生成模型的mesh文件路径,每一行只写一个文件</li>
<li>-o, --output-file OUTPUT_FILE ：输出模型文件的路径</li>
<li>-p, --procrustes PROCRUSTES_MODE ：选择数据对齐（aligned）模式。如果选择<strong>reference</strong>，所有的数据和指定的参考mesh对齐；如果选择<strong>GPA</strong>，则和均值对齐</li>
<li>-r, --reference FILE ：在<em>PROCRUSTES_MODE</em>选择<strong>reference</strong>之后，指定参考mesh</li>
<li>-n, --noise NOISE ：指定PPCA(probabilistic principal component analysis)模型的噪声方差，默认为0</li>
</ul>
<hr>
<h2 id="读入mesh文件的代码"><a class="markdownIt-Anchor" href="#读入mesh文件的代码"></a> 读入mesh文件的代码</h2>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> itk::MeshFileReader<meshtype> MeshReaderType;</meshtype></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span><meshreadertype::pointer> MeshReaderList;</meshreadertype::pointer></span><br><span class="line">MeshReaderList meshes;</span><br><span class="line">meshes.reserve(fileNames.size());</span><br><span class="line"><span class="keyword">for</span> (StringList::const_iterator it = fileNames.begin(); it != fileNames.end();</span><br><span class="line">    ++it) </span><br><span class="line">{</span><br><span class="line">  MeshReaderType::Pointer reader = MeshReaderType::New();</span><br><span class="line">  reader->SetFileName(it->c_str());</span><br><span class="line">  reader->Update();</span><br><span class="line">  <span class="comment">//这段注释是说Update()这个函数很重要</span></span><br><span class="line">  <span class="comment">// itk::PCAModelBuilder is not a Filter in the ITK world, so the pipeline</span></span><br><span class="line">  <span class="comment">// would not get executed if its main method is called. So the pipeline</span></span><br><span class="line">  <span class="comment">// before calling itk::PCAModelBuilder must be executed by the means of calls</span></span><br><span class="line">  <span class="comment">// to Update() (at least for last elements needed by itk::PCAModelBuilder).</span></span><br><span class="line">  meshes.push_back(reader);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>关于为什么要用Update()的解释:<br>
You only have to call Update() on the last filter in your pipeline. The rest of this answer is the explanation.<br>
ITK uses a pipeline execution framework for filters. Assume we have three filters that are connected sequentially like the following:<br>
input --> |filter1| --> |filter2| --> |filter3| --> output<br>
If you call Update() on filter3, ITK starts from filter3 and checks if the input(s) to each filter have changed. If they have, ITK calls update on them in turn. See slide 5 of this <a href="www.cs.cmu.edu/~galeotti/methods_course/ITK_Pipeline.pdf">link</a>.</p>
<hr>
<h2 id="计算平均mesh作为参考mesh的代码"><a class="markdownIt-Anchor" href="#计算平均mesh作为参考mesh的代码"></a> 计算平均mesh作为参考mesh的代码</h2>
<p>originalMeshes传入的是meshes的指针，也就是align也会影响meshes</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> itk::Mesh<<span class="keyword">float</span>, Dimensions> MeshType;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将已经读入的mesh都拷贝过来，mesh为之前读入的文件</span></span><br><span class="line"><span class="built_in">vector</span><meshtype::pointer> originalMeshes;</meshtype::pointer></span><br><span class="line"><span class="keyword">for</span> (MeshReaderList::iterator it = meshes.begin(); it != meshes.end();</span><br><span class="line">    ++it) </span><br><span class="line">{</span><br><span class="line">  MeshReaderType::Pointer reader = *it;</span><br><span class="line">  originalMeshes.push_back(reader->GetOutput());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> uMaxGPAIterations = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> uNumberOfPoints = <span class="number">100</span>;  <span class="comment">// 最多使用这么多个点</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> fBreakIfChangeBelow = <span class="number">0.001f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> itk::VersorRigid3DTransform<<span class="keyword">float</span>> Rigid3DTransformType;</span><br><span class="line"><span class="keyword">typedef</span> itk::Image<<span class="keyword">float</span>, Dimensions> ImageType;</span><br><span class="line"><span class="keyword">typedef</span> itk::LandmarkBasedTransformInitializer<rigid3dtransformtype,< span=""><br><span class="line">                                                   ImageType, ImageType></span><br><span class="line">    LandmarkBasedTransformInitializerType;</span><br><span class="line"><span class="keyword">typedef</span> itk::TransformMeshFilter<meshtype, meshtype,="" rigid3dtransformtype=""></meshtype,></span><br><span class="line">    FilterType;</span><br><span class="line"><span class="comment">// 计算参考mesh</span></span><br><span class="line">MeshType::Pointer referenceMesh =</span><br><span class="line">    calculateProcrustesMeanMesh<meshtype,< span=""><br><span class="line">                                LandmarkBasedTransformInitializerType,</span><br><span class="line">                                Rigid3DTransformType, FilterType>(</span><br><span class="line">        originalMeshes, uMaxGPAIterations, uNumberOfPoints,</span><br><span class="line">        fBreakIfChangeBelow);</span><br><span class="line">representer->SetReference(referenceMesh);</span><br></meshtype,<></span></rigid3dtransformtype,<></span></pre></td></tr></tbody></table></figure>
<h3 id="计算参考mesh的函数"><a class="markdownIt-Anchor" href="#计算参考mesh的函数"></a> 计算参考mesh的函数</h3>
<p>计算流程：</p>
<ol>
<li>随机取出一些点，只使用这些点进行align</li>
<li>以其中一帧mesh作为初始参考对所有帧进行align</li>
<li>对align后的所有mesh算一个平均mesh</li>
<li>计算当前参考mesh和当前平均mesh的差值</li>
<li>如果差值比较大并且没有达到最大迭代次数就用当前平均mesh覆盖当前参考mesh然后跳转回2，否则返回当前平均mesh</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> <<span class="class"><span class="keyword">class</span> <span class="title">MeshType</span>, <span class="title">class</span> <span class="title">LandmarkBasedTransformInitializerType</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">TransformType</span>, <span class="title">class</span> <span class="title">FilterType</span>></span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">MeshType</span>:</span>:Pointer</span><br><span class="line">calculateProcrustesMeanMesh(<span class="built_in">std</span>::<span class="built_in">vector</span><<span class="keyword">typename</span> MeshType::Pointer> meshes,</span><br><span class="line">                            <span class="keyword">unsigned</span> maxIterations, <span class="keyword">unsigned</span> nrOfLandmarks,</span><br><span class="line">                            <span class="keyword">float</span> breakIfChangeBelow) </span><br><span class="line">{</span><br><span class="line">  <span class="comment">// the initial mesh to which all others will be aligned to is the first one in</span></span><br><span class="line">  <span class="comment">// the list here. Any other mesh could be chosen as well</span></span><br><span class="line">  <span class="comment">// 设定第一帧mesh为初始参考mesh</span></span><br><span class="line">  <span class="keyword">typename</span> MeshType::Pointer referenceMesh = *meshes.begin();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> rngSeed = time(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">unsigned</span> meshVerticesCount = referenceMesh->GetNumberOfPoints();</span><br><span class="line">  srand(rngSeed);  <span class="comment">// 随机数生成器，跟rand()有关</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">set</span><<span class="keyword">unsigned</span>> pointNumbers;</span><br><span class="line">  <span class="comment">// 使用点的数量不能超过nrOfLandmarks</span></span><br><span class="line">  <span class="comment">// 使用点的索引是随机获取的</span></span><br><span class="line">  <span class="keyword">while</span> (pointNumbers.size() < <span class="built_in">std</span>::min(nrOfLandmarks, meshVerticesCount)) </span><br><span class="line">  {</span><br><span class="line">    <span class="comment">// 随机获得一个点的索引，但是没有多余的处理是否会添加重复的点？</span></span><br><span class="line">    <span class="keyword">unsigned</span> randomIndex = ((<span class="keyword">unsigned</span>)rand()) % meshVerticesCount;</span><br><span class="line">    pointNumbers.insert(randomIndex);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">float</span> fPreviousDifference = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 进入迭代</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i < maxIterations; ++i) </span><br><span class="line">  {</span><br><span class="line">    <span class="comment">// calculate the difference to the previous iteration's mesh and break if</span></span><br><span class="line">    <span class="comment">// the difference is very small</span></span><br><span class="line">    <span class="comment">// 计算每一个mesh和当前参考mesh之间的刚体变换，并且进行align</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span><<span class="keyword">typename</span> MeshType::Pointer> translatedMeshes =</span><br><span class="line">        superimposeMeshes<meshtype, landmarkbasedtransforminitializertype,<="" span=""><br><span class="line">                          TransformType, FilterType>(meshes, referenceMesh,</span><br><span class="line">                                                     pointNumbers);</span><br><span class="line">    <span class="comment">// 计算align后的平均mesh</span></span><br><span class="line">    <span class="keyword">typename</span> MeshType::Pointer meanMesh =</span><br><span class="line">        calculateMeanMesh<meshtype>(translatedMeshes);</meshtype></span><br><span class="line">    <span class="comment">// 计算当前平均mesh和当前参考mesh的差值</span></span><br><span class="line">    <span class="keyword">float</span> fDifference =</span><br><span class="line">        calculateMeshDistance<meshtype>(meanMesh, referenceMesh);</meshtype></span><br><span class="line">    <span class="keyword">float</span> fDifferenceDelta = <span class="built_in">std</span>::<span class="built_in">abs</span>(fDifference - fPreviousDifference);</span><br><span class="line">    fPreviousDifference = fDifference;</span><br><span class="line">    referenceMesh = meanMesh;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果小于阈值认为收敛了</span></span><br><span class="line">    <span class="keyword">if</span> (fDifferenceDelta < breakIfChangeBelow) </span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> referenceMesh;</span><br><span class="line">}</span><br></meshtype,></span></pre></td></tr></tbody></table></figure>
<h3 id="align的函数"><a class="markdownIt-Anchor" href="#align的函数"></a> Align的函数</h3>
<p>使用随机采样的对应点计算每一帧mesh和当前参考mesh之间的刚体变换，并且进行align</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> <<span class="class"><span class="keyword">class</span> <span class="title">MeshType</span>, <span class="title">class</span> <span class="title">LandmarkBasedTransformInitializerType</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">TransformType</span>, <span class="title">class</span> <span class="title">FilterType</span>></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">std</span>:</span>:<span class="built_in">vector</span><<span class="keyword">typename</span> MeshType::Pointer></span><br><span class="line"></span><br><span class="line">superimposeMeshes(<span class="built_in">std</span>::<span class="built_in">vector</span><<span class="keyword">typename</span> MeshType::Pointer> originalMeshes,</span><br><span class="line">                  <span class="keyword">typename</span> MeshType::Pointer referenceMesh,</span><br><span class="line">                  <span class="built_in">std</span>::<span class="built_in">set</span><<span class="keyword">unsigned</span>> landmarkIndices) </span><br><span class="line">{</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span><<span class="keyword">typename</span> MeshType::Pointer> translatedMeshes(</span><br><span class="line">      originalMeshes.begin(), originalMeshes.end());</span><br><span class="line">  <span class="comment">//遍历每一帧mesh，计算每一mesh相对于当前参考mesh的刚体变换并align</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">typename</span> <span class="built_in">std</span>::<span class="built_in">vector</span><<span class="keyword">typename</span> MeshType::Pointer>::iterator it =</span><br><span class="line">           translatedMeshes.begin();</span><br><span class="line">       it != translatedMeshes.end(); ++it) </span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">typedef</span></span><br><span class="line">        <span class="keyword">typename</span> LandmarkBasedTransformInitializerType::LandmarkPointContainer</span><br><span class="line">            LandmarkContainerType;</span><br><span class="line">    LandmarkContainerType movingLandmarks;</span><br><span class="line">    LandmarkContainerType fixedLandmarks;</span><br><span class="line">    <span class="keyword">typename</span> MeshType::Pointer movingMesh = *it;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据点数和拓扑都需要一致（实际上索引相同的点需要已经对应好）</span></span><br><span class="line">    <span class="keyword">if</span> (movingMesh->GetNumberOfPoints() != referenceMesh->GetNumberOfPoints() ||</span><br><span class="line">        movingMesh->GetNumberOfCells() != referenceMesh->GetNumberOfCells()) </span><br><span class="line">    {</span><br><span class="line">      itkGenericExceptionMacro(</span><br><span class="line">          << <span class="string">"All meshes must have the same number of Edges & Vertices"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only use a subset of the meshes' points for the alignment since we don't</span></span><br><span class="line">    <span class="comment">// have that many degrees of freedom anyways and since calculating a SVD with</span></span><br><span class="line">    <span class="comment">// too many points is expensive</span></span><br><span class="line">    <span class="comment">// 使用前面随机选出来的部分点进行计算</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">set</span><<span class="keyword">unsigned</span>>::const_iterator rng = landmarkIndices.begin();</span><br><span class="line">         rng != landmarkIndices.end(); ++rng) </span><br><span class="line">    {</span><br><span class="line">      movingLandmarks.push_back(movingMesh->GetPoint(*rng));</span><br><span class="line">      fixedLandmarks.push_back(referenceMesh->GetPoint(*rng));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// only rotate & translate the moving mesh to best fit with the fixed mesh;</span></span><br><span class="line">    <span class="comment">// there's no scaling taking place.</span></span><br><span class="line">    <span class="comment">// 使用这一部分点计算mesh和当前参考mesh之间的刚体变换</span></span><br><span class="line">    <span class="keyword">typename</span> LandmarkBasedTransformInitializerType::Pointer</span><br><span class="line">        landmarkBasedTransformInitializer =</span><br><span class="line">            LandmarkBasedTransformInitializerType::New();</span><br><span class="line">    landmarkBasedTransformInitializer->SetFixedLandmarks(fixedLandmarks);</span><br><span class="line">    landmarkBasedTransformInitializer->SetMovingLandmarks(movingLandmarks);</span><br><span class="line">    <span class="keyword">typename</span> TransformType::Pointer transform = TransformType::New();</span><br><span class="line">    transform->SetIdentity();</span><br><span class="line">    landmarkBasedTransformInitializer->SetTransform(transform);</span><br><span class="line">    landmarkBasedTransformInitializer->InitializeTransform();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用计算得到的刚体变换进行align，这里是mesh上所有的点</span></span><br><span class="line">    <span class="keyword">typename</span> FilterType::Pointer filter = FilterType::New();</span><br><span class="line">    filter->SetInput(movingMesh);</span><br><span class="line">    filter->SetTransform(transform);</span><br><span class="line">    filter->Update();</span><br><span class="line"></span><br><span class="line">    *it = filter->GetOutput();</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> translatedMeshes;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="计算平均mesh的函数"><a class="markdownIt-Anchor" href="#计算平均mesh的函数"></a> 计算平均mesh的函数</h3>
<p>遍历求和，然后遍历求平均</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> <<span class="class"><span class="keyword">class</span> <span class="title">MeshType</span>></span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">MeshType</span>:</span>:Pointer</span><br><span class="line">calculateMeanMesh(<span class="built_in">std</span>::<span class="built_in">vector</span><<span class="keyword">typename</span> MeshType::Pointer> meshes) </span><br><span class="line">{</span><br><span class="line">  <span class="comment">// 必须要存在mesh</span></span><br><span class="line">  <span class="keyword">if</span> (meshes.size() == <span class="number">0</span>) </span><br><span class="line">  {</span><br><span class="line">    itkGenericExceptionMacro(</span><br><span class="line">        << <span class="string">"Can't calculate the mean since no meshes were provided."</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用这个类型的原因是这个类型精度更高</span></span><br><span class="line">  <span class="keyword">typedef</span> itk::CompensatedSummation<<span class="keyword">typename</span> MeshType::PixelType></span><br><span class="line">      CompensatedSummationType;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">vector</span><compensatedsummationtype> MeshPointsVectorType;</compensatedsummationtype></span><br><span class="line"></span><br><span class="line">  <span class="keyword">typename</span> MeshType::Pointer pFirstMesh = *meshes.begin();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// prepare for summation</span></span><br><span class="line">  MeshPointsVectorType vMeshPoints;</span><br><span class="line">  <span class="comment">// shape向量的长度，点数乘上每个点的维度</span></span><br><span class="line">  <span class="keyword">unsigned</span> uDataSize =</span><br><span class="line">      pFirstMesh->GetNumberOfPoints() * MeshType::PointDimension;</span><br><span class="line">  vMeshPoints.reserve(uDataSize);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < uDataSize; ++i) </span><br><span class="line">  {</span><br><span class="line">    CompensatedSummationType sum;</span><br><span class="line">    vMeshPoints.push_back(sum);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历每个mesh</span></span><br><span class="line">  <span class="comment">// 求和</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">typename</span> <span class="built_in">std</span>::<span class="built_in">vector</span><<span class="keyword">typename</span> MeshType::Pointer>::const_iterator i =</span><br><span class="line">           meshes.begin();</span><br><span class="line">       i != meshes.end(); ++i) </span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">typename</span> MeshType::Pointer pMesh = *i;</span><br><span class="line">    <span class="comment">// 验证向量维度(点的个数和点的维度)要一样</span></span><br><span class="line">    <span class="keyword">if</span> (vMeshPoints.size() !=</span><br><span class="line">        pMesh->GetNumberOfPoints() * MeshType::PointDimension) </span><br><span class="line">    {</span><br><span class="line">      itkGenericExceptionMacro(</span><br><span class="line">          << <span class="string">"All meshes must have the same number of Edges"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typename</span> MeshPointsVectorType::iterator sum = vMeshPoints.begin();</span><br><span class="line">    <span class="keyword">typename</span> MeshType::PointsContainer::ConstIterator pointData =</span><br><span class="line">        pMesh->GetPoints()->Begin();</span><br><span class="line">    <span class="comment">// sum up all meshes</span></span><br><span class="line">    <span class="comment">// 遍历这个mesh的每个点</span></span><br><span class="line">    <span class="keyword">for</span> (; pointData != pMesh->GetPoints()->End(); ++pointData) </span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">typename</span> MeshType::PointType point = pointData->Value();</span><br><span class="line">      <span class="comment">// 遍历这个点的每个维度</span></span><br><span class="line">      <span class="comment">// 将对应维度的数值加入vMeshPoints中</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">typename</span> MeshType::PointType::ConstIterator pointIter =</span><br><span class="line">               point.Begin();</span><br><span class="line">           pointIter != point.End(); ++pointIter, ++sum) </span><br><span class="line">      {</span><br><span class="line">        (*sum) += *pointIter;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">float</span> fInvNumberOfMeshes = <span class="number">1.0f</span> / meshes.size();</span><br><span class="line">  <span class="comment">// 虽然是复制的第一帧mesh，但是后面是直接覆盖</span></span><br><span class="line">  <span class="keyword">typename</span> MeshType::Pointer pMeanMesh = cloneMesh<meshtype>(pFirstMesh);</meshtype></span><br><span class="line"></span><br><span class="line">  <span class="comment">// write the data to the mean mesh</span></span><br><span class="line">  <span class="keyword">typename</span> MeshPointsVectorType::iterator sum = vMeshPoints.begin();</span><br><span class="line">  <span class="comment">// 遍历meanmesh的每个点</span></span><br><span class="line">  <span class="comment">// 计算平均值</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">typename</span> MeshType::PointsContainer::Iterator pointData =</span><br><span class="line">           pMeanMesh->GetPoints()->Begin();</span><br><span class="line">       pointData != pMeanMesh->GetPoints()->End(); ++pointData) </span><br><span class="line">  {</span><br><span class="line">    <span class="comment">// 遍历点的每个维度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">typename</span> MeshType::PointType::Iterator pointIter =</span><br><span class="line">             pointData->Value().Begin();</span><br><span class="line">         pointIter != pointData->Value().End(); ++pointIter, ++sum) </span><br><span class="line">    {</span><br><span class="line">      <span class="comment">// 计算平均值传给meanmesh</span></span><br><span class="line">      *pointIter = sum->GetSum() * fInvNumberOfMeshes;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pMeanMesh;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="计算平均mesh和当前参考mesh的差值"><a class="markdownIt-Anchor" href="#计算平均mesh和当前参考mesh的差值"></a> 计算平均mesh和当前参考mesh的差值</h3>
<p>每对对应点的距离求和，再除以shape向量的整体维度进行平均</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> <<span class="class"><span class="keyword">class</span> <span class="title">MeshType</span>></span></span><br><span class="line"><span class="class"><span class="title">float</span> <span class="title">calculateMeshDistance</span>(<span class="title">typename</span> <span class="title">MeshType</span>:</span>:Pointer mesh1,</span><br><span class="line">                            <span class="keyword">typename</span> MeshType::Pointer mesh2) </span><br><span class="line">{</span><br><span class="line">  <span class="comment">// 点数和拓扑要一样（实际上也需要完全对应）</span></span><br><span class="line">  <span class="keyword">if</span> (mesh1->GetNumberOfPoints() != mesh2->GetNumberOfPoints() ||</span><br><span class="line">      mesh1->GetNumberOfCells() != mesh2->GetNumberOfCells()) </span><br><span class="line">  {</span><br><span class="line">    itkGenericExceptionMacro(</span><br><span class="line">        << <span class="string">"Both meshes must have the same number of Edges & Vertices"</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">float</span> fDifference = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> MeshType::PointsContainer::Iterator IteratorType;</span><br><span class="line">  IteratorType point1 = mesh1->GetPoints()->Begin();</span><br><span class="line">  IteratorType point2 = mesh2->GetPoints()->Begin();</span><br><span class="line">  <span class="comment">// 每对对应点的距离求和</span></span><br><span class="line">  <span class="keyword">for</span> (; point1 != mesh1->GetPoints()->End(); ++point1, ++point2) </span><br><span class="line">  {</span><br><span class="line">    fDifference += point1->Value().SquaredEuclideanDistanceTo(point2->Value());</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 除以（mesh点的个数 乘上 点的维度）</span></span><br><span class="line">  fDifference /= (mesh1->GetNumberOfPoints() * MeshType::PointDimension);</span><br><span class="line">  <span class="keyword">return</span> fDifference;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h2 id="将参考帧加入数据管理"><a class="markdownIt-Anchor" href="#将参考帧加入数据管理"></a> 将参考帧加入数据管理</h2>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> itk::Mesh<<span class="keyword">float</span>, Dimensions> MeshType;</span><br><span class="line"><span class="keyword">typedef</span> itk::DataManager<meshtype> DataManagerType;</meshtype></span><br><span class="line">DataManagerType::Pointer dataManager = DataManagerType::New();</span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////</span></span><br><span class="line">dataManager->SetRepresenter(representer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (MeshReaderList::const_iterator it = meshes.begin(); it != meshes.end();</span><br><span class="line">      ++it) {</span><br><span class="line">  MeshReaderType::Pointer reader = *it;</span><br><span class="line">  dataManager->AddDataset(reader->GetOutput(), reader->GetFileName());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h2 id="进行pca并保存model"><a class="markdownIt-Anchor" href="#进行pca并保存model"></a> 进行PCA并保存model</h2>
<p>这个PCA之前没有align的过程？？GPA会进行align，但是如果选择reference这里就没有进行align了？</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// model类型</span></span><br><span class="line"><span class="keyword">typedef</span> itk::StatisticalModel<meshtype> StatisticalModelType;</meshtype></span><br><span class="line">StatisticalModelType::Pointer model;</span><br><span class="line"><span class="comment">// 进行PCA</span></span><br><span class="line"><span class="keyword">typedef</span> itk::PCAModelBuilder<meshtype> PCAModelBuilder;</meshtype></span><br><span class="line">PCAModelBuilder::Pointer pcaModelBuilder = PCAModelBuilder::New();</span><br><span class="line"><span class="comment">// 直接就进行PCA了</span></span><br><span class="line">model = pcaModelBuilder->BuildNewModel(dataManager->GetData(),</span><br><span class="line">                                         opt.fNoiseVariance);</span><br><span class="line"><span class="comment">// 保存为文件</span></span><br><span class="line">itk::StatismoIO<meshtype>::SaveStatisticalModel(</meshtype></span><br><span class="line">    model, opt.strOutputFileName.c_str());</span><br></pre></td></tr></tbody></table></figure>
<p><strong>PCA函数</strong><br>
比较常规的PCA计算过程</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> <<span class="keyword">typename</span> T> PCAModelBuilder<t>::PCAModelBuilder() : Superclass() {}</t></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> <<span class="keyword">typename</span> T></span><br><span class="line"><span class="keyword">typename</span> PCAModelBuilder<t>::StatisticalModelType *</t></span><br><span class="line">PCAModelBuilder<t>::BuildNewModel(<span class="keyword">const</span> DataItemListType &sampleDataList,</t></span><br><span class="line">                                  <span class="keyword">double</span> noiseVariance, <span class="keyword">bool</span> computeScores,</span><br><span class="line">                                  EigenValueMethod method) <span class="keyword">const</span> {</span><br><span class="line">  <span class="comment">// 设定数据样本个数</span></span><br><span class="line">  <span class="keyword">unsigned</span> n = sampleDataList.size();</span><br><span class="line">  <span class="keyword">if</span> (n <= <span="" class="number">0<!--=--></span=""></span>) {<br><span class="line">    <span class="keyword">throw</span> StatisticalModelException(</span><br><span class="line">        <span class="string">"Provided empty sample set. Cannot build the sample matrix"</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> p = sampleDataList.front()->GetSampleVector().rows();</span><br><span class="line">  <span class="keyword">const</span> Representer<t> *representer = sampleDataList.front()->GetRepresenter();</t></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compute the mean vector mu</span></span><br><span class="line">  <span class="comment">// 求和在平均得到重心</span></span><br><span class="line">  VectorType mu = VectorType::Zero(p);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">typename</span> DataItemListType::const_iterator it = sampleDataList.begin();</span><br><span class="line">       it != sampleDataList.end(); ++it) {</span><br><span class="line">    assert((*it)->GetSampleVector().rows() ==</span><br><span class="line">           p); <span class="comment">// all samples must have same number of rows</span></span><br><span class="line">    assert((*it)->GetRepresenter() ==</span><br><span class="line">           representer); <span class="comment">// all samples have the same representer</span></span><br><span class="line">    mu += (*it)->GetSampleVector();</span><br><span class="line">  }</span><br><span class="line">  mu /= n;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Build the mean free sample matrix X0</span></span><br><span class="line">  <span class="comment">// 减去重心，中心化</span></span><br><span class="line">  <span class="function">MatrixType <span class="title">X0</span><span class="params">(n, p)</span></span>;</span><br><span class="line">  <span class="keyword">unsigned</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">typename</span> DataItemListType::const_iterator it = sampleDataList.begin();</span><br><span class="line">       it != sampleDataList.end(); ++it) {</span><br><span class="line">    X0.row(i++) = (*it)->GetSampleVector() - mu;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// build the model</span></span><br><span class="line">  <span class="comment">// 使用SVD或者特征值分解等方式计算</span></span><br><span class="line">  StatisticalModelType *model =</span><br><span class="line">      BuildNewModelInternal(representer, X0, mu, noiseVariance, method);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> model;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<script src="https://cdnjs.loli.net/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: 开始
ed=>end: 退出
io1=>inputoutput: 输入命令行参数
op1=>operation: 读取命令行参数
cond1=>condition: 参数是否
符合要求？
io2=>inputoutput: 无法执行
op2=>operation: 读入mesh文件
cond2=>condition: 输入参数是否设
置了参考mesh？
op3=>operation: 按照设置选择已有
mesh为参考mesh
op4=>operation: 计算参考mesh
(有相关代码详解)
op5=>operation: 设定参考mesh并将每
帧mesh加入数据管理
op6=>operation: 进行PCA
io3=>inputoutput: 保存model文件

st->io1->op1->cond1
cond1(no)->io2->ed
cond1(yes)->op2->cond2
cond2(yes, right)->op3->op5
cond2(no)->op4->op5
op5->op6->io3->ed</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script>
      
    </div>

    

    
    
    

    

    
       
    
    

    
      <div>
        



  



<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>OptSolution</li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    
    <a href="https://optsolution.github.io/archives/34417.html" title="statismo代码分析--statismo-build-shape-model">https://optsolution.github.io/archives/34417.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/statismo/" rel="tag"># statismo</a>
          
            <a href="/tags/code/" rel="tag"># code</a>
          
            <a href="/tags/SSM/" rel="tag"># SSM</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/archives/58892.html" rel="next" title="Bundle Adjustment简述">
                <i class="fa fa-chevron-left"></i> Bundle Adjustment简述
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/archives/26365.html" rel="prev" title="statismo代码分析--statismo-build-deformation-model">
                statismo代码分析--statismo-build-deformation-model <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div id="gitalk-container"></div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="OptSolution">
            
              <p class="site-author-name" itemprop="name">OptSolution</p>
              <p class="site-description motion-element" itemprop="description">做每一件有意义的小事</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">13</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">24</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:mr_cwang@foxmail.com" title="E-Mail → mailto:mr_cwang@foxmail.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          
             <div class="cc-license motion-element" itemprop="license">
              
                
              
              
              
              <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="external nofollow noopener noreferrer" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
             </div>
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#流程图"><span class="nav-number">1.</span> <span class="nav-text"> 流程图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#命令行参数"><span class="nav-number">2.</span> <span class="nav-text"> 命令行参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#读入mesh文件的代码"><span class="nav-number">3.</span> <span class="nav-text"> 读入mesh文件的代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#计算平均mesh作为参考mesh的代码"><span class="nav-number">4.</span> <span class="nav-text"> 计算平均mesh作为参考mesh的代码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#计算参考mesh的函数"><span class="nav-number">4.1.</span> <span class="nav-text"> 计算参考mesh的函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#align的函数"><span class="nav-number">4.2.</span> <span class="nav-text"> Align的函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#计算平均mesh的函数"><span class="nav-number">4.3.</span> <span class="nav-text"> 计算平均mesh的函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#计算平均mesh和当前参考mesh的差值"><span class="nav-number">4.4.</span> <span class="nav-text"> 计算平均mesh和当前参考mesh的差值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#将参考帧加入数据管理"><span class="nav-number">5.</span> <span class="nav-text"> 将参考帧加入数据管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进行pca并保存model"><span class="nav-number">6.</span> <span class="nav-text"> 进行PCA并保存model</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <meta name="generator" content="Hexo 3.8.0"><div class="copyright">© <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">OptSolution</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="external nofollow noopener noreferrer" target="_blank">NexT.Mist</a> v6.5.0</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv" title="总访客量">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="site-pv" title="总访问量">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
      <div>
        <!-- Go to www.addthis.com/dashboard to customize your tools -->
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5c19d72a5c8d8b6e" async="async"></script>
      </div>
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.5.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.5.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  










  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
  <script src="/js/src/md5.min.js"></script>
   <script type="text/javascript">
        var gitalk = new Gitalk({
          clientID: '987a1c65d0da11fba55f',
          clientSecret: '540d011a80a8f1758eb15c63b2f23ca332012295',
          repo: 'OptSolution.github.io',
          owner: 'OptSolution',
          admin: ['OptSolution'],
          id: md5(location.pathname),
          distractionFreeMode: 'true'
        })
        gitalk.render('gitalk-container')           
       </script>


  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  
  

  

  

  

  

  

  




</body></html>